################################################################################
#                                                                              #
#                        BACKEND CODE EXPORT                                   #
#                      Laravel 11 + MySQL 8.0                                  #
#                                                                              #
#  Export Date: 2026-02-28 08:00:02                                          #
#  Timestamp: 2026-02-28_08-00-02                                                   #
#                                                                              #
################################################################################

=================================================================================
FILE: composer.json
LOCATION: .//composer.json
=================================================================================

{
    "$schema": "https://getcomposer.org/schema.json",
    "name": "laravel/laravel",
    "type": "project",
    "description": "The skeleton application for the Laravel framework.",
    "keywords": ["laravel", "framework"],
    "license": "MIT",
    "require": {
        "php": "^8.2",
        "barryvdh/laravel-dompdf": "^3.1",
        "laravel/framework": "^12.0",
        "laravel/sanctum": "^4.3",
        "laravel/tinker": "^2.10.1"
    },
    "require-dev": {
        "fakerphp/faker": "^1.23",
        "laravel/pail": "^1.2.2",
        "laravel/pint": "^1.24",
        "laravel/sail": "^1.41",
        "mockery/mockery": "^1.6",
        "nunomaduro/collision": "^8.6",
        "phpunit/phpunit": "^11.5.3"
    },
    "autoload": {
        "psr-4": {
            "App\\": "app/",
            "Database\\Factories\\": "database/factories/",
            "Database\\Seeders\\": "database/seeders/"
        }
    },
    "autoload-dev": {
        "psr-4": {
            "Tests\\": "tests/"
        }
    },
    "scripts": {
        "setup": [
            "composer install",
            "@php -r \"file_exists('.env') || copy('.env.example', '.env');\"",
            "@php artisan key:generate",
            "@php artisan migrate --force",
            "npm install",
            "npm run build"
        ],
        "dev": [
            "Composer\\Config::disableProcessTimeout",
            "npx concurrently -c \"#93c5fd,#c4b5fd,#fb7185,#fdba74\" \"php artisan serve\" \"php artisan queue:listen --tries=1 --timeout=0\" \"php artisan pail --timeout=0\" \"npm run dev\" --names=server,queue,logs,vite --kill-others"
        ],
        "test": [
            "@php artisan config:clear --ansi",
            "@php artisan test"
        ],
        "post-autoload-dump": [
            "Illuminate\\Foundation\\ComposerScripts::postAutoloadDump",
            "@php artisan package:discover --ansi"
        ],
        "post-update-cmd": [
            "@php artisan vendor:publish --tag=laravel-assets --ansi --force"
        ],
        "post-root-package-install": [
            "@php -r \"file_exists('.env') || copy('.env.example', '.env');\""
        ],
        "post-create-project-cmd": [
            "@php artisan key:generate --ansi",
            "@php -r \"file_exists('database/database.sqlite') || touch('database/database.sqlite');\"",
            "@php artisan migrate --graceful --ansi"
        ],
        "pre-package-uninstall": [
            "Illuminate\\Foundation\\ComposerScripts::prePackageUninstall"
        ]
    },
    "extra": {
        "laravel": {
            "dont-discover": []
        }
    },
    "config": {
        "optimize-autoloader": true,
        "preferred-install": "dist",
        "sort-packages": true,
        "allow-plugins": {
            "pestphp/pest-plugin": true,
            "php-http/discovery": true
        }
    },
    "minimum-stability": "stable",
    "prefer-stable": true
}


=================================================================================
FILE: database/migrations/0001_01_01_000000_create_users_table.php
LOCATION: .//database/migrations/0001_01_01_000000_create_users_table.php
=================================================================================

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
use App\Enums\UserRole; // IMPORT

return new class extends Migration {
    public function up(): void
    {
        Schema::create('users', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->string('email')->unique();
            $table->timestamp('email_verified_at')->nullable();
            $table->string('password');
            $table->string('pin_code')->nullable();

            $table->enum('role', array_column(UserRole::cases(), 'value'))
                ->default(UserRole::PRODUCTION_EMPLOYEE->value);

            $table->boolean('is_active')->default(true);
            $table->rememberToken();
            $table->timestamps();
        });

        // ... reszta pliku (password_reset_tokens, sessions) bez zmian
        Schema::create('password_reset_tokens', function (Blueprint $table) {
            $table->string('email')->primary();
            $table->string('token');
            $table->timestamp('created_at')->nullable();
        });

        Schema::create('sessions', function (Blueprint $table) {
            $table->string('id')->primary();
            $table->foreignId('user_id')->nullable()->index();
            $table->string('ip_address', 45)->nullable();
            $table->text('user_agent')->nullable();
            $table->longText('payload');
            $table->integer('last_activity')->index();
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('users');
        Schema::dropIfExists('password_reset_tokens');
        Schema::dropIfExists('sessions');
    }
};


=================================================================================
FILE: database/migrations/0001_01_01_000001_create_cache_table.php
LOCATION: .//database/migrations/0001_01_01_000001_create_cache_table.php
=================================================================================

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('cache', function (Blueprint $table) {
            $table->string('key')->primary();
            $table->mediumText('value');
            $table->integer('expiration')->index();
        });

        Schema::create('cache_locks', function (Blueprint $table) {
            $table->string('key')->primary();
            $table->string('owner');
            $table->integer('expiration')->index();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('cache');
        Schema::dropIfExists('cache_locks');
    }
};


=================================================================================
FILE: database/migrations/0001_01_01_000002_create_jobs_table.php
LOCATION: .//database/migrations/0001_01_01_000002_create_jobs_table.php
=================================================================================

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('jobs', function (Blueprint $table) {
            $table->id();
            $table->string('queue')->index();
            $table->longText('payload');
            $table->unsignedTinyInteger('attempts');
            $table->unsignedInteger('reserved_at')->nullable();
            $table->unsignedInteger('available_at');
            $table->unsignedInteger('created_at');
        });

        Schema::create('job_batches', function (Blueprint $table) {
            $table->string('id')->primary();
            $table->string('name');
            $table->integer('total_jobs');
            $table->integer('pending_jobs');
            $table->integer('failed_jobs');
            $table->longText('failed_job_ids');
            $table->mediumText('options')->nullable();
            $table->integer('cancelled_at')->nullable();
            $table->integer('created_at');
            $table->integer('finished_at')->nullable();
        });

        Schema::create('failed_jobs', function (Blueprint $table) {
            $table->id();
            $table->string('uuid')->unique();
            $table->text('connection');
            $table->text('queue');
            $table->longText('payload');
            $table->longText('exception');
            $table->timestamp('failed_at')->useCurrent();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('jobs');
        Schema::dropIfExists('job_batches');
        Schema::dropIfExists('failed_jobs');
    }
};


=================================================================================
FILE: database/migrations/2026_02_01_164443_create_personal_access_tokens_table.php
LOCATION: .//database/migrations/2026_02_01_164443_create_personal_access_tokens_table.php
=================================================================================

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('personal_access_tokens', function (Blueprint $table) {
            $table->id();
            $table->morphs('tokenable');
            $table->text('name');
            $table->string('token', 64)->unique();
            $table->text('abilities')->nullable();
            $table->timestamp('last_used_at')->nullable();
            $table->timestamp('expires_at')->nullable()->index();
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('personal_access_tokens');
    }
};


=================================================================================
FILE: database/migrations/2026_02_01_174443_01_create_customers_table.php
LOCATION: .//database/migrations/2026_02_01_174443_01_create_customers_table.php
=================================================================================

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
use App\Enums\CustomerType; // IMPORT

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('customers', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->string('nip', 10)->nullable();
            $table->string('email')->nullable();
            $table->string('phone', 20)->nullable();
            $table->text('address')->nullable();

            // Dynamiczne wartości
            $table->enum('type', array_column(CustomerType::cases(), 'value'))
                  ->default(CustomerType::B2B->value);

            $table->boolean('is_active')->default(true);
            $table->timestamps();

            $table->index('name');
            $table->index('nip');
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('customers');
    }
};


=================================================================================
FILE: database/migrations/2026_02_01_174444_02_create_assortment_table.php
LOCATION: .//database/migrations/2026_02_01_174444_02_create_assortment_table.php
=================================================================================

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
use App\Enums\AssortmentType; // IMPORT
use App\Enums\AssortmentUnit; // IMPORT

return new class extends Migration {
    public function up(): void
    {
        Schema::create('assortment', function (Blueprint $table) {
            $table->id();

            $table->enum('type', array_column(AssortmentType::cases(), 'value'));

            $table->string('name');
            $table->string('category');

            // Jeśli chcesz wymusić tylko jednostki z Enuma w bazie:
            $table->enum('unit', array_column(AssortmentUnit::cases(), 'value'));
            // Jeśli wolisz elastyczność (string), zostaw $table->string('unit');

            $table->decimal('default_price', 10, 2);
            $table->text('description')->nullable();
            $table->boolean('is_active')->default(true);
            $table->timestamps();

            $table->index('type');
            $table->index('category');
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('assortment');
    }
};


=================================================================================
FILE: database/migrations/2026_02_01_174445_03_create_orders_table.php
LOCATION: .//database/migrations/2026_02_01_174445_03_create_orders_table.php
=================================================================================

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
use App\Enums\OrderOverallStatus;
use App\Enums\PaymentStatus;
use App\Enums\OrderPriority;

return new class extends Migration {
    public function up(): void
    {
        Schema::create('orders', function (Blueprint $table) {
            $table->id();
            $table->foreignId('customer_id')->constrained()->onDelete('cascade');

            // ZMIANA: order_number nie jest już unikalny sam w sobie (unikalna jest para order_number + series)
// Zakładamy 4 cyfry
            $table->string('order_number', 4);

            // NOWE: Seria (4 cyfry)
            $table->string('series', 4);

            // ZMIANA: Brief -> Opis
            $table->text('description');

            // NOWE: Planowana data realizacji
            $table->date('planned_delivery_date')->nullable();

            $table->enum('overall_status', array_column(OrderOverallStatus::cases(), 'value'))
                ->default(OrderOverallStatus::DRAFT->value);

            $table->enum('payment_status', array_column(PaymentStatus::cases(), 'value'))
                ->default(PaymentStatus::UNPAID->value);

            $table->enum('priority', array_column(OrderPriority::cases(), 'value'))
                ->default(OrderPriority::NORMAL->value);

            $table->timestamps();

            $table->index(['customer_id', 'overall_status']);

            // Unikalność pary numer + seria
            $table->unique(['order_number', 'series']);
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('orders');
    }
};


=================================================================================
FILE: database/migrations/2026_02_01_174446_04_create_variants_table.php
LOCATION: .//database/migrations/2026_02_01_174446_04_create_variants_table.php
=================================================================================

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
use App\Enums\VariantType;
use App\Enums\VariantStatus;

return new class extends Migration {
    public function up(): void
    {
        // Dropujemy tabelę, aby odświeżyć strukturę (środowisko dev)
        Schema::dropIfExists('variants');

        Schema::create('variants', function (Blueprint $table) {
            $table->id();
            $table->foreignId('order_id')->constrained()->onDelete('cascade');

            // Relacja rodzic–dziecko dla duplikowania wariantów.
            // Dziecko (A1, A2) ma parent_variant_id = id rodzica (A).
            // Brat (B, C) ma parent_variant_id = null.
            $table->unsignedBigInteger('parent_variant_id')->nullable();

            // Numeracja wariantu w ramach zamówienia (A, B, C... lub A1, A2...)
            $table->string('variant_number');

            $table->string('name');
            $table->text('description')->nullable();
            $table->integer('quantity');

            // Typ: Prototyp / Seryjna
            $table->enum('type', array_column(VariantType::cases(), 'value'))
                ->default(VariantType::SERIAL->value);

            // Status: DRAFT, QUOTATION, PRODUCTION...
            $table->enum('status', array_column(VariantStatus::cases(), 'value'))
                ->default(VariantStatus::DRAFT->value);

            // Pola specyficzne dla zatwierdzania (np. prototypu)
            $table->boolean('is_approved')->default(false);
            $table->text('feedback_notes')->nullable();

            // Link do starego systemu prototypów (opcjonalny, zostawiamy dla kompatybilności wstecznej jeśli potrzebne)
            $table->unsignedBigInteger('approved_prototype_id')->nullable();

            $table->timestamps();

            $table->index(['order_id', 'variant_number']);

            // Klucz obcy do samej tabeli (self-referencing)
            // Definiujemy po timestamps, bo tabela musi istnieć przed FK
            $table->foreign('parent_variant_id')
                ->references('id')
                ->on('variants')
                ->nullOnDelete();

            $table->boolean('is_group')
                ->default(false);
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('variants');
    }
};


=================================================================================
FILE: database/migrations/2026_02_01_174447_05_create_quotations_table.php
LOCATION: .//database/migrations/2026_02_01_174447_05_create_quotations_table.php
=================================================================================

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration {
    public function up(): void
    {
        Schema::create('quotations', function (Blueprint $table) {
            $table->id();
            $table->foreignId('variant_id')->constrained('variants')->onDelete('cascade');

            $table->integer('version_number')->default(1);

            $table->decimal('total_materials_cost', 10, 2)->default(0);
            $table->decimal('total_services_cost', 10, 2)->default(0);
            $table->decimal('total_net', 10, 2)->default(0);
            $table->decimal('total_gross', 10, 2)->default(0);
            $table->decimal('margin_percent', 5, 2)->default(0);

            $table->boolean('is_approved')->default(false);
            $table->timestamp('approved_at')->nullable();
            $table->foreignId('approved_by_user_id')->nullable()->constrained('users')->onDelete('set null');

            $table->text('notes')->nullable();

            $table->timestamps();

            // Unikalna para: variant + version
            $table->unique(['variant_id', 'version_number']);
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('quotations');
    }
};


=================================================================================
FILE: database/migrations/2026_02_01_174448_06_create_quotation_items_table.php
LOCATION: .//database/migrations/2026_02_01_174448_06_create_quotation_items_table.php
=================================================================================

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('quotation_items', function (Blueprint $table) {
            $table->id();
            $table->foreignId('quotation_id')->constrained('quotations')->onDelete('cascade');
            
            $table->decimal('materials_cost', 10, 2)->default(0);
            $table->decimal('services_cost', 10, 2)->default(0);
            $table->decimal('subtotal', 10, 2)->default(0);
            
            $table->timestamps();
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('quotation_items');
    }
};


=================================================================================
FILE: database/migrations/2026_02_01_174449_07_create_quotation_item_materials_table.php
LOCATION: .//database/migrations/2026_02_01_174449_07_create_quotation_item_materials_table.php
=================================================================================

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('quotation_item_materials', function (Blueprint $table) {
            $table->id();
            $table->foreignId('quotation_item_id')->constrained()->onDelete('cascade');
            $table->foreignId('assortment_item_id')->constrained('assortment')->onDelete('cascade');
            $table->decimal('quantity', 10, 2);
            $table->string('unit');
            $table->decimal('unit_price', 10, 2);
            $table->decimal('total_cost', 10, 2);
            $table->text('notes')->nullable();
            $table->timestamps();
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('quotation_item_materials');
    }
};


=================================================================================
FILE: database/migrations/2026_02_01_174450_08_create_quotation_item_services_table.php
LOCATION: .//database/migrations/2026_02_01_174450_08_create_quotation_item_services_table.php
=================================================================================

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('quotation_item_services', function (Blueprint $table) {
            $table->id();
            $table->foreignId('quotation_item_id')->constrained()->onDelete('cascade');
            $table->foreignId('assortment_item_id')->constrained('assortment')->onDelete('cascade');
            $table->decimal('estimated_quantity', 10, 2);
            $table->decimal('estimated_time_hours', 10, 2);
            $table->string('unit');
            $table->decimal('unit_price', 10, 2);
            $table->decimal('total_cost', 10, 2);
            $table->text('notes')->nullable();
            $table->timestamps();
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('quotation_item_services');
    }
};


=================================================================================
FILE: database/migrations/2026_02_01_174451_09_create_prototypes_table.php
LOCATION: .//database/migrations/2026_02_01_174451_09_create_prototypes_table.php
=================================================================================

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
use App\Enums\TestResult;

return new class extends Migration {
    public function up(): void
    {
        Schema::create('prototypes', function (Blueprint $table) {
            $table->id();
            $table->foreignId('variant_id')->constrained()->onDelete('cascade');
            $table->integer('version_number');
            $table->boolean('is_approved')->default(false);
            $table->enum('test_result', array_column(TestResult::cases(), 'value'))
                ->default(TestResult::PENDING->value);
            $table->text('feedback_notes')->nullable();
            $table->date('sent_to_client_date')->nullable();
            $table->date('client_response_date')->nullable();
            $table->timestamps();

            $table->unique(['variant_id', 'version_number']);
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('prototypes');
    }
};


=================================================================================
FILE: database/migrations/2026_02_01_174452_10_create_workstations_table.php
LOCATION: .//database/migrations/2026_02_01_174452_10_create_workstations_table.php
=================================================================================

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
use App\Enums\WorkstationType;
use App\Enums\WorkstationStatus;

return new class extends Migration {
    public function up(): void
    {
        Schema::create('workstations', function (Blueprint $table) {
            $table->id();
            $table->string('name')->unique();

            $table->enum('type', array_column(WorkstationType::cases(), 'value'));

            // Statusy techniczne maszyn można zostawić jako stringi lub zrobić dla nich osobny Enum
            // Dla uproszczenia tutaj zostawiamy hardcoded uppercase, ale można dodać WorkstationStatus Enum
            $table->enum('status', array_column(WorkstationStatus::cases(), 'value'))
                ->default(WorkstationStatus::IDLE->value);

            $table->unsignedBigInteger('current_task_id')->nullable();
            $table->string('location')->nullable();
            $table->timestamps();

            $table->index('status');
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('workstations');
    }
};


=================================================================================
FILE: database/migrations/2026_02_01_174453_11_create_workstation_operators_table.php
LOCATION: .//database/migrations/2026_02_01_174453_11_create_workstation_operators_table.php
=================================================================================

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('workstation_operators', function (Blueprint $table) {
            $table->id();
            $table->foreignId('workstation_id')->constrained()->onDelete('cascade');
            $table->foreignId('user_id')->constrained()->onDelete('cascade');
            $table->boolean('is_primary')->default(false);
            $table->timestamps();
            
            $table->unique(['workstation_id', 'user_id']);
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('workstation_operators');
    }
};


=================================================================================
FILE: database/migrations/2026_02_01_174454_12_create_production_orders_table.php
LOCATION: .//database/migrations/2026_02_01_174454_12_create_production_orders_table.php
=================================================================================

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
use App\Enums\ProductionStatus;

return new class extends Migration {
    public function up(): void
    {
        Schema::create('production_orders', function (Blueprint $table) {
            $table->id();
            $table->foreignId('variant_id')->constrained()->onDelete('cascade');
            $table->integer('quantity');

            // Koszty
            $table->decimal('total_estimated_cost', 10, 2)->default(0);
            $table->decimal('total_actual_cost', 10, 2)->default(0);

            $table->enum('status', array_column(ProductionStatus::cases(), 'value'))
                ->default(ProductionStatus::PLANNED->value);

            // Daty
            $table->timestamp('started_at')->nullable();
            $table->timestamp('completed_at')->nullable();

            $table->timestamps();

            $table->index(['variant_id', 'status']);
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('production_orders');
    }
};


=================================================================================
FILE: database/migrations/2026_02_01_174455_13_create_production_services_table.php
LOCATION: .//database/migrations/2026_02_01_174455_13_create_production_services_table.php
=================================================================================

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
use App\Enums\ProductionStatus;

return new class extends Migration {
    public function up(): void
    {
        Schema::create('production_services', function (Blueprint $table) {
            $table->id();
            $table->foreignId('production_order_id')->constrained()->onDelete('cascade');
            $table->integer('step_number');
            $table->string('service_name');
            $table->foreignId('workstation_id')->constrained();
            $table->foreignId('assigned_to_user_id')->nullable()->constrained('users')->nullOnDelete();

            // Szacowane
            $table->decimal('estimated_quantity', 10, 2);
            $table->decimal('estimated_time_hours', 10, 2);
            $table->decimal('unit_price', 10, 2);
            $table->decimal('estimated_cost', 10, 2);

            // Rzeczywiste
            $table->decimal('actual_quantity', 10, 2)->nullable();
            $table->decimal('actual_time_hours', 10, 2)->nullable();
            $table->decimal('actual_cost', 10, 2)->nullable();

            // Wariancje
            $table->decimal('time_variance_hours', 10, 2)->nullable();
            $table->decimal('cost_variance', 10, 2)->nullable();
            $table->decimal('variance_percent', 8, 2)->nullable();

            // Timer
            $table->integer('total_pause_duration_seconds')->default(0);

            $table->enum('status', array_column(ProductionStatus::cases(), 'value'))
                ->default(ProductionStatus::PLANNED->value);

            // Daty
            $table->date('planned_start_date')->nullable();
            $table->date('planned_end_date')->nullable();
            $table->timestamp('actual_start_date')->nullable();
            $table->timestamp('actual_end_date')->nullable();

            $table->text('worker_notes')->nullable();

            $table->timestamps();

            $table->index('status');
            $table->index('workstation_id');
            $table->index('assigned_to_user_id');
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('production_services');
    }
};


=================================================================================
FILE: database/migrations/2026_02_01_174456_14_create_service_time_logs_table.php
LOCATION: .//database/migrations/2026_02_01_174456_14_create_service_time_logs_table.php
=================================================================================

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
use App\Enums\EventType;

return new class extends Migration {
    public function up(): void
    {
        Schema::create('service_time_logs', function (Blueprint $table) {
            $table->id();
            $table->foreignId('production_service_id')->constrained()->onDelete('cascade');
            $table->foreignId('user_id')->constrained();
            $table->enum('event_type', array_column(EventType::cases(), 'value'));
            $table->timestamp('event_timestamp');
            $table->integer('elapsed_seconds')->nullable();
            $table->timestamps();

            $table->index(['production_service_id', 'event_type']);
            $table->index('event_timestamp');
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('service_time_logs');
    }
};


=================================================================================
FILE: database/migrations/2026_02_01_174458_16_create_deliveries_table.php
LOCATION: .//database/migrations/2026_02_01_174458_16_create_deliveries_table.php
=================================================================================

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
use App\Enums\DeliveryStatus;

return new class extends Migration {
    public function up(): void
    {
        Schema::create('deliveries', function (Blueprint $table) {
            $table->id();
            $table->foreignId('variant_id')->constrained()->onDelete('cascade');
            $table->string('delivery_number')->unique();
            $table->date('delivery_date');
            $table->string('tracking_number')->nullable();
            $table->string('courier')->nullable();
            $table->enum('status', array_column(DeliveryStatus::cases(), 'value'))
                ->default(DeliveryStatus::SCHEDULED->value);
            $table->timestamp('delivered_at')->nullable();
            $table->text('notes')->nullable();
            $table->timestamps();

            $table->index('status');
            $table->index('delivery_number');
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('deliveries');
    }
};


=================================================================================
FILE: database/migrations/2026_02_01_174459_17_create_invoices_table.php
LOCATION: .//database/migrations/2026_02_01_174459_17_create_invoices_table.php
=================================================================================

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
use App\Enums\InvoiceStatus;

return new class extends Migration {
    public function up(): void
    {
        Schema::create('invoices', function (Blueprint $table) {
            $table->id();
            $table->foreignId('order_id')->constrained()->onDelete('cascade');
            $table->string('invoice_number')->unique();
            $table->decimal('total_net', 10, 2);
            $table->decimal('total_gross', 10, 2);
            $table->date('issue_date');
            $table->date('payment_deadline');
            $table->enum('status', array_column(InvoiceStatus::cases(), 'value'))
                ->default(InvoiceStatus::ISSUED->value);
            $table->timestamp('paid_at')->nullable();
            $table->timestamps();

            $table->index('status');
            $table->index('invoice_number');
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('invoices');
    }
};


=================================================================================
FILE: database/migrations/2026_02_01_174500_18_create_payments_table.php
LOCATION: .//database/migrations/2026_02_01_174500_18_create_payments_table.php
=================================================================================

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
use App\Enums\PaymentMethod;

return new class extends Migration {
    public function up(): void
    {
        Schema::create('payments', function (Blueprint $table) {
            $table->id();
            $table->foreignId('invoice_id')->constrained()->onDelete('cascade');
            $table->decimal('amount', 10, 2);
            $table->date('payment_date');
            $table->enum('payment_method', array_column(PaymentMethod::cases(), 'value'));

            $table->string('transaction_id')->nullable();
            $table->text('notes')->nullable();
            $table->timestamps();

            $table->index('payment_date');
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('payments');
    }
};


=================================================================================
FILE: database/migrations/2026_02_02_223024_create_assortment_history_table.php
LOCATION: .//database/migrations/2026_02_02_223024_create_assortment_history_table.php
=================================================================================

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
use App\Enums\AssortmentHistoryAction;

return new class extends Migration {
    public function up(): void
    {
        Schema::create('assortment_history', function (Blueprint $table) {
            $table->id();
            $table->foreignId('assortment_id')->constrained('assortment')->onDelete('cascade');
            $table->foreignId('user_id')->nullable()->constrained('users')->nullOnDelete();
            $table->enum('action', array_column(AssortmentHistoryAction::cases(), 'value'));
            $table->json('old_values')->nullable();
            $table->json('new_values')->nullable();
            $table->text('description')->nullable();
            $table->timestamps();

            $table->index(['assortment_id', 'created_at']);
            $table->index('action');
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('assortment_history');
    }
};


=================================================================================
FILE: database/migrations/2026_02_02_999999_create_order_images_table.php
LOCATION: .//database/migrations/2026_02_02_999999_create_order_images_table.php
=================================================================================

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration {
    public function up(): void {
        Schema::dropIfExists('line_images');
        Schema::create('order_images', function (Blueprint $table) {
            $table->id();
            $table->foreignId('order_id')->constrained()->onDelete('cascade');
            $table->string('filename');
            $table->string('path');
            $table->string('thumbnail_path')->nullable();
            $table->string('mime_type');
            $table->integer('size');
            $table->text('description')->nullable();
            $table->integer('sort_order')->default(0);
            $table->timestamps();
        });
    }
    public function down(): void {
        Schema::dropIfExists('order_images');
    }
};


=================================================================================
FILE: database/migrations/2026_02_04_211025_create_assortment_workstation_table.php
LOCATION: .//database/migrations/2026_02_04_211025_create_assortment_workstation_table.php
=================================================================================

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration {
    public function up(): void
    {
        Schema::create('assortment_workstation', function (Blueprint $table) {
            $table->id();
            $table->foreignId('workstation_id')->constrained()->onDelete('cascade');
            $table->foreignId('assortment_id')->constrained('assortment')->onDelete('cascade');
            $table->timestamps();

            // Zapobiegamy dublowaniu par
            $table->unique(['workstation_id', 'assortment_id']);
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('assortment_workstation');
    }
};


=================================================================================
FILE: database/migrations/2026_02_15_000001_create_variant_materials_table.php
LOCATION: .//database/migrations/2026_02_15_000001_create_variant_materials_table.php
=================================================================================

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
use App\Enums\MaterialStatus;

return new class extends Migration {
    public function up(): void
    {
        Schema::create('variant_materials', function (Blueprint $table) {
            $table->id();
            $table->foreignId('variant_id')->constrained()->onDelete('cascade');
            $table->foreignId('assortment_id')->constrained('assortment')->onDelete('cascade');

            // Ilość i cena
            $table->decimal('quantity', 10, 2);
            $table->string('unit');
            $table->decimal('unit_price', 10, 2);
            $table->decimal('total_cost', 10, 2);

            // Status zamówienia/dostępności materiału
            $table->enum('status', array_column(MaterialStatus::cases(), 'value'))
                ->default(MaterialStatus::NOT_ORDERED->value);

            // Daty logistyczne
            $table->date('expected_delivery_date')->nullable();
            $table->date('ordered_at')->nullable();
            $table->date('received_at')->nullable();

            // Ilość na stanie vs zamówiona
            $table->decimal('quantity_in_stock', 10, 2)->default(0);
            $table->decimal('quantity_ordered', 10, 2)->default(0);

            // Dostawca
            $table->string('supplier')->nullable();

            $table->text('notes')->nullable();
            $table->timestamps();

            $table->index(['variant_id', 'status']);
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('variant_materials');
    }
};


=================================================================================
FILE: database/migrations/2026_02_15_000002_create_prototype_materials_table.php
LOCATION: .//database/migrations/2026_02_15_000002_create_prototype_materials_table.php
=================================================================================

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
use App\Enums\MaterialStatus;

return new class extends Migration {
    public function up(): void
    {
        Schema::create('prototype_materials', function (Blueprint $table) {
            $table->id();
            $table->foreignId('prototype_id')->constrained()->onDelete('cascade');
            $table->foreignId('assortment_id')->constrained('assortment')->onDelete('cascade');

            // Ilość i cena
            $table->decimal('quantity', 10, 2);
            $table->string('unit');
            $table->decimal('unit_price', 10, 2);
            $table->decimal('total_cost', 10, 2);

            // Status zamówienia/dostępności
            $table->enum('status', array_column(MaterialStatus::cases(), 'value'))
                ->default(MaterialStatus::NOT_ORDERED->value);

            // Daty logistyczne
            $table->date('expected_delivery_date')->nullable();
            $table->date('ordered_at')->nullable();
            $table->date('received_at')->nullable();

            // Ilość na stanie vs zamówiona
            $table->decimal('quantity_in_stock', 10, 2)->default(0);
            $table->decimal('quantity_ordered', 10, 2)->default(0);

            // Dostawca
            $table->string('supplier')->nullable();

            $table->text('notes')->nullable();
            $table->timestamps();

            $table->index(['prototype_id', 'status']);
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('prototype_materials');
    }
};


=================================================================================
FILE: database/migrations/2026_02_15_000003_create_prototype_services_table.php
LOCATION: .//database/migrations/2026_02_15_000003_create_prototype_services_table.php
=================================================================================

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
use App\Enums\ProductionStatus;

return new class extends Migration {
    public function up(): void
    {
        Schema::create('prototype_services', function (Blueprint $table) {
            $table->id();
            $table->foreignId('prototype_id')->constrained()->onDelete('cascade');
            $table->integer('step_number');
            $table->string('service_name');
            $table->foreignId('workstation_id')->nullable()->constrained();
            $table->foreignId('assigned_to_user_id')->nullable()->constrained('users')->nullOnDelete();

            // Szacowane
            $table->decimal('estimated_quantity', 10, 2)->default(1);
            $table->decimal('estimated_time_hours', 10, 2)->default(0);
            $table->decimal('unit_price', 10, 2)->default(0);
            $table->decimal('estimated_cost', 10, 2)->default(0);

            // Rzeczywiste
            $table->decimal('actual_quantity', 10, 2)->nullable();
            $table->decimal('actual_time_hours', 10, 2)->nullable();
            $table->decimal('actual_cost', 10, 2)->nullable();

            // Timer
            $table->integer('total_pause_duration_seconds')->default(0);

            $table->enum('status', array_column(ProductionStatus::cases(), 'value'))
                ->default(ProductionStatus::PLANNED->value);

            // Daty
            $table->timestamp('actual_start_date')->nullable();
            $table->timestamp('actual_end_date')->nullable();

            $table->text('worker_notes')->nullable();

            $table->timestamps();

            $table->index(['prototype_id', 'status']);
            $table->index('workstation_id');
            $table->index('assigned_to_user_id');
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('prototype_services');
    }
};


=================================================================================
FILE: app/Models/Assortment.php
LOCATION: .//app/Models/Assortment.php
=================================================================================

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use App\Enums\AssortmentType;
use App\Enums\AssortmentUnit;
use App\Enums\AssortmentHistoryAction;

class Assortment extends Model
{
    protected $table = 'assortment';

    protected $fillable = [
        'type',
        'name',
        'category',
        'unit',
        'default_price',
        'description',
        'is_active',
    ];


    protected $casts = [
        'type' => AssortmentType::class,
        'unit' => AssortmentUnit::class,
        'default_price' => 'decimal:2',
        'is_active' => 'boolean',
    ];

    // Boot method dla automatycznego logowania zmian
    protected static function boot()
    {
        parent::boot();

        static::created(function ($assortment) {
            $assortment->logHistory(
                AssortmentHistoryAction::CREATED,
                null,
                $assortment->getAttributes(),
                'Pozycja utworzona'
            );
        });

        static::updated(function ($assortment) {
            $changes = $assortment->getChanges();
            if (!empty($changes)) {
                unset($changes['updated_at']);
                if (!empty($changes)) {
                    $assortment->logHistory(
                        AssortmentHistoryAction::UPDATED,
                        $assortment->getOriginal(),
                        $changes
                    );
                }
            }
        });

        static::deleted(function ($assortment) {
            $assortment->logHistory(
                AssortmentHistoryAction::DELETED,
                $assortment->getAttributes(),
                null,
                'Pozycja usunięta'
            );
        });
    }

    /**
     * Historia zmian
     */
    public function history()
    {
        return $this->hasMany(AssortmentHistory::class)->orderBy('created_at', 'desc');
    }

    /**
     * Loguj zmianę
     */
    public function logHistory($action, $oldValues = null, $newValues = null, $description = null)
    {
        // Konwersja string na Enum jeśli potrzeba
        if (is_string($action)) {
            $action = AssortmentHistoryAction::from($action);
        }

        return AssortmentHistory::create([
            'assortment_id' => $this->id,
            'user_id' => auth()->id(),
            'action' => $action,
            'old_values' => $oldValues,
            'new_values' => $newValues,
            'description' => $description,
        ]);
    }

    public function scopeMaterials($query)
    {
        return $query->where('type', 'material');
    }

    public function scopeServices($query)
    {
        return $query->where('type', 'service');
    }

    public function scopeActive($query)
    {
        return $query->where('is_active', true);
    }


}


=================================================================================
FILE: app/Models/AssortmentHistory.php
LOCATION: .//app/Models/AssortmentHistory.php
=================================================================================

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use App\Enums\AssortmentHistoryAction;

class AssortmentHistory extends Model
{
    protected $table = 'assortment_history';

    protected $fillable = [
        'assortment_id',
        'user_id',
        'action',
        'old_values',
        'new_values',
        'description',
    ];

    protected $casts = [
        'old_values' => 'array',
        'new_values' => 'array',
        'created_at' => 'datetime',
        'action' => AssortmentHistoryAction::class,
    ];

    public function assortment()
    {
        return $this->belongsTo(Assortment::class);
    }

    public function user()
    {
        return $this->belongsTo(User::class);
    }

    /**
     * Pobierz opis zmiany
     */
    public function getChangeDescriptionAttribute()
    {
        if ($this->description) {
            return $this->description;
        }

        $changes = [];

        if ($this->old_values && $this->new_values) {
            foreach ($this->new_values as $key => $newValue) {
                $oldValue = $this->old_values[$key] ?? null;

                if ($oldValue != $newValue) {
                    $changes[] = $this->formatFieldChange($key, $oldValue, $newValue);
                }
            }
        }

        return !empty($changes) ? implode(', ', $changes) : 'Brak zmian';
    }

    /**
     * Formatuj zmianę pola
     */
    private function formatFieldChange($field, $oldValue, $newValue)
    {
        $fieldLabels = [
            'name' => 'Nazwa',
            'type' => 'Typ',
            'category' => 'Kategoria',
            'unit' => 'Jednostka',
            'default_price' => 'Cena',
            'description' => 'Opis',
            'is_active' => 'Status'
        ];

        $label = $fieldLabels[$field] ?? $field;

        if ($field === 'is_active') {
            $oldValue = $oldValue ? 'Aktywna' : 'Nieaktywna';
            $newValue = $newValue ? 'Aktywna' : 'Nieaktywna';
        } elseif ($field === 'default_price') {
            $oldValue = number_format($oldValue, 2, ',', ' ') . ' PLN';
            $newValue = number_format($newValue, 2, ',', ' ') . ' PLN';
        }

        return "{$label}: {$oldValue} → {$newValue}";
    }
}


=================================================================================
FILE: app/Models/Customer.php
LOCATION: .//app/Models/Customer.php
=================================================================================

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use App\Enums\CustomerType;

class Customer extends Model
{
    protected $fillable = [
        'name',
        'nip',
        'email',
        'phone',
        'address',
        'type',
        'is_active',
    ];

    protected $casts = [
        'is_active' => 'boolean',
        'type' => CustomerType::class,
    ];

    public function orders()
    {
        return $this->hasMany(Order::class);
    }
}


=================================================================================
FILE: app/Models/Delivery.php
LOCATION: .//app/Models/Delivery.php
=================================================================================

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use App\Enums\DeliveryStatus;

class Delivery extends Model
{
    protected $fillable = [
        'variant_id',
        'delivery_number',
        'delivery_date',
        'tracking_number',
        'courier',
        'status',
        'delivered_at',
        'notes',
    ];

    protected $casts = [
        'delivery_date' => 'date',
        'delivered_at' => 'datetime',
        'status' => DeliveryStatus::class,
    ];

    public function variant()
    {
        return $this->belongsTo(Variant::class);
    }
}


=================================================================================
FILE: app/Models/Invoice.php
LOCATION: .//app/Models/Invoice.php
=================================================================================

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use App\Enums\InvoiceStatus;

class Invoice extends Model
{
    protected $fillable = [
        'order_id',
        'invoice_number',
        'total_net',
        'total_gross',
        'issue_date',
        'payment_deadline',
        'status',
        'paid_at',
    ];

    protected $casts = [
        'total_net' => 'decimal:2',
        'total_gross' => 'decimal:2',
        'issue_date' => 'date',
        'payment_deadline' => 'date',
        'paid_at' => 'datetime',
        'status' => InvoiceStatus::class,
    ];

    public function order()
    {
        return $this->belongsTo(Order::class);
    }

    public function payments()
    {
        return $this->hasMany(Payment::class);
    }
}


=================================================================================
FILE: app/Models/Order.php
LOCATION: .//app/Models/Order.php
=================================================================================

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\HasManyThrough;

use App\Enums\OrderOverallStatus;
use App\Enums\PaymentStatus;
use App\Enums\OrderPriority;

class Order extends Model
{
    protected $fillable = [
        'customer_id',
        'order_number',
        'series',
        'description', // Zmiana z brief
        'planned_delivery_date', // Nowe pole
        'overall_status',
        'payment_status',
        'priority',
    ];

    protected $casts = [
        'overall_status' => OrderOverallStatus::class,
        'payment_status' => PaymentStatus::class,
        'priority' => OrderPriority::class,
        'planned_delivery_date' => 'date',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
    ];

    // Dodajemy append, aby frontend łatwo dostał pełny numer
    protected $appends = ['full_order_number'];

    /**
     * Logika generowania serii dla danego numeru zamówienia.
     */
    public static function generateSeries(string $orderNumber): string
    {
        // Pobierz najwyższą serię dla tego numeru
        $lastSeries = self::where('order_number', $orderNumber)
            ->max('series');

        if (!$lastSeries) {
            return '0001';
        }

        $nextSeries = intval($lastSeries) + 1;
        return str_pad((string) $nextSeries, 4, '0', STR_PAD_LEFT);
    }

    /**
     * Akcesor dla pełnego numeru wyświetlanego na froncie: Z/XXXX/YYYY
     */
    public function getFullOrderNumberAttribute(): string
    {
        return "Z/{$this->order_number}/{$this->series}";
    }

    /**
     * Klient
     */
    public function customer(): BelongsTo
    {
        return $this->belongsTo(Customer::class);
    }

    /**
     * Warianty
     */
    public function variants(): HasMany
    {
        return $this->hasMany(Variant::class);
    }

    /**
     * Wyceny (przez warianty)
     */
    public function quotations(): HasManyThrough
    {
        return $this->hasManyThrough(Quotation::class, Variant::class);
    }

    /**
     * Faktury
     */
    public function invoices(): HasMany
    {
        return $this->hasMany(Invoice::class);
    }

    /**
     * Zdjęcia
     */
    public function images(): HasMany
    {
        return $this->hasMany(OrderImage::class)->orderBy('sort_order');
    }

    /**
     * Zlecenia produkcyjne (przez warianty)
     */
    public function productionOrders(): HasManyThrough
    {
        return $this->hasManyThrough(ProductionOrder::class, Variant::class);
    }

    /**
     * Sprawdź czy zamówienie ma zatwierdzoną wycenę
     */
    public function hasApprovedQuotation(): bool
    {
        return $this->quotations()->where('is_approved', true)->exists();
    }

    /**
     * Pobierz sumę wartości wszystkich zatwierdzonych wycen
     */
    public function getApprovedQuotationsTotalAttribute(): float
    {
        return $this->quotations()
            ->where('is_approved', true)
            ->sum('total_gross');
    }
}


=================================================================================
FILE: app/Models/OrderImage.php
LOCATION: .//app/Models/OrderImage.php
=================================================================================

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Support\Facades\Storage;

class OrderImage extends Model
{
    protected $fillable = [
        'order_id',
        'filename',
        'path',
        'thumbnail_path',
        'mime_type',
        'size',
        'description',
        'sort_order'
    ];

    protected $appends = ['url', 'thumbnail_url'];

    public function order()
    {
        return $this->belongsTo(Order::class);
    }

    public function getUrlAttribute()
    {
        return Storage::url($this->path);
    }

    public function getThumbnailUrlAttribute()
    {
        if ($this->thumbnail_path) {
            return Storage::url($this->thumbnail_path);
        }
        return $this->url;
    }
}


=================================================================================
FILE: app/Models/Payment.php
LOCATION: .//app/Models/Payment.php
=================================================================================

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use App\Enums\PaymentMethod;

class Payment extends Model
{
    protected $fillable = [
        'invoice_id',
        'amount',
        'payment_date',
        'payment_method',
        'transaction_id',
        'notes',
    ];

    protected $casts = [
        'amount' => 'decimal:2',
        'payment_date' => 'date',
        'payment_method' => PaymentMethod::class,
    ];

    public function invoice()
    {
        return $this->belongsTo(Invoice::class);
    }
}


=================================================================================
FILE: app/Models/ProductionOrder.php
LOCATION: .//app/Models/ProductionOrder.php
=================================================================================

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

class ProductionOrder extends Model
{
    protected $fillable = [
        'variant_id',
        'quantity',
        'total_estimated_cost',
        'total_actual_cost',
        'status',
        'started_at',
        'completed_at',
    ];

    protected $casts = [
        'total_estimated_cost' => 'decimal:2',
        'total_actual_cost' => 'decimal:2',
        'started_at' => 'datetime',
        'completed_at' => 'datetime',
    ];

    /**
     * Wariant
     */
    public function variant(): BelongsTo
    {
        return $this->belongsTo(Variant::class);
    }

    /**
     * Usługi produkcyjne (zadania)
     */
    public function services(): HasMany
    {
        return $this->hasMany(ProductionService::class);
    }
}


=================================================================================
FILE: app/Models/ProductionService.php
LOCATION: .//app/Models/ProductionService.php
=================================================================================

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use App\Enums\ProductionStatus;

class ProductionService extends Model
{
    use HasFactory;

    protected $fillable = [
        'production_order_id',
        'step_number',
        'service_name',
        'workstation_id',
        'assigned_to_user_id',
        'estimated_quantity',
        'estimated_time_hours',
        'unit_price',
        'estimated_cost',
        'actual_quantity',
        'actual_time_hours',
        'actual_cost',
        'time_variance_hours',
        'cost_variance',
        'variance_percent',
        'total_pause_duration_seconds',
        'status',
        'planned_start_date',
        'planned_end_date',
        'actual_start_date',
        'actual_end_date',
        'worker_notes',
    ];

    protected $casts = [
        'estimated_quantity' => 'decimal:2',
        'estimated_time_hours' => 'decimal:2',
        'unit_price' => 'decimal:2',
        'estimated_cost' => 'decimal:2',
        'actual_quantity' => 'decimal:2',
        'actual_time_hours' => 'decimal:2',
        'actual_cost' => 'decimal:2',
        'time_variance_hours' => 'decimal:2',
        'cost_variance' => 'decimal:2',
        'variance_percent' => 'decimal:2',
        'planned_start_date' => 'date',
        'planned_end_date' => 'date',
        'actual_start_date' => 'datetime',
        'actual_end_date' => 'datetime',
        'status' => ProductionStatus::class,
    ];

    public function productionOrder()
    {
        return $this->belongsTo(ProductionOrder::class);
    }

    public function workstation()
    {
        return $this->belongsTo(Workstation::class);
    }

    public function assignedWorker()
    {
        return $this->belongsTo(User::class, 'assigned_to_user_id');
    }

    public function timeLogs()
    {
        return $this->hasMany(ServiceTimeLog::class);
    }

    public function scopePending($query)
    {
        return $query->where('status', 'planned');
    }

    public function scopeInProgress($query)
    {
        return $query->where('status', ProductionStatus::IN_PROGRESS);
    }

    public function isActive(): bool
    {
        return $this->status === ProductionStatus::IN_PROGRESS;
    }

    public function isPaused(): bool
    {
        return $this->status === ProductionStatus::PAUSED;
    }
}


=================================================================================
FILE: app/Models/Prototype.php
LOCATION: .//app/Models/Prototype.php
=================================================================================

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use App\Enums\TestResult;
use App\Enums\MaterialStatus;
use App\Enums\ProductionStatus;

/**
 * Model Prototype (Prototyp)
 *
 * Każdy prototyp ma ODDZIELNE:
 * - Materiały (prototype_materials) — niezależne od materiałów wariantu/produkcji seryjnej
 * - Zadania RCP (prototype_services) — niezależne od production_services linii seryjnej
 *
 * Wariant może mieć wiele prototypów, ale tylko jeden zatwierdzony.
 */
class Prototype extends Model
{
    protected $fillable = [
        'variant_id',
        'version_number',
        'is_approved',
        'test_result',
        'feedback_notes',
        'sent_to_client_date',
        'client_response_date',
    ];

    protected $casts = [
        'is_approved' => 'boolean',
        'sent_to_client_date' => 'date',
        'client_response_date' => 'date',
        'test_result' => TestResult::class,
    ];

    // =========================================================================
    // RELACJE
    // =========================================================================

    /**
     * Wariant, do którego należy prototyp
     */
    public function variant(): BelongsTo
    {
        return $this->belongsTo(Variant::class);
    }

    /**
     * Materiały prototypu (ODDZIELNE od materiałów wariantu)
     * Prototyp ma swoją własną listę materiałów z info o zamówieniach/stanach
     */
    public function materials(): HasMany
    {
        return $this->hasMany(PrototypeMaterial::class);
    }

    /**
     * Zadania produkcyjne / RCP prototypu (ODDZIELNE od production_services)
     * Prototyp ma swoje własne zadania robocze
     */
    public function services(): HasMany
    {
        return $this->hasMany(PrototypeService::class);
    }

    // =========================================================================
    // MATERIAŁY - HELPERY
    // =========================================================================

    /**
     * Czy wszystkie materiały prototypu są na stanie
     */
    public function allMaterialsInStock(): bool
    {
        if ($this->materials->isEmpty()) {
            return true; // prototyp bez materiałów = gotowy
        }

        return $this->materials->every(fn($m) => $m->status === MaterialStatus::IN_STOCK);
    }

    /**
     * Łączny koszt materiałów prototypu
     */
    public function getTotalMaterialsCostAttribute(): float
    {
        return (float) $this->materials->sum('total_cost');
    }

    /**
     * Podsumowanie statusów materiałów prototypu
     */
    public function getMaterialsStatusSummaryAttribute(): array
    {
        $materials = $this->materials;

        return [
            'total' => $materials->count(),
            'not_ordered' => $materials->where('status', MaterialStatus::NOT_ORDERED)->count(),
            'ordered' => $materials->where('status', MaterialStatus::ORDERED)->count(),
            'in_stock' => $materials->where('status', MaterialStatus::IN_STOCK)->count(),
            'all_ready' => $this->allMaterialsInStock(),
        ];
    }

    // =========================================================================
    // RCP / SERVICES - HELPERY
    // =========================================================================

    /**
     * Czy wszystkie zadania RCP prototypu zostały zakończone
     */
    public function allServicesCompleted(): bool
    {
        if ($this->services->isEmpty()) {
            return true;
        }

        return $this->services->every(fn($s) => $s->status === ProductionStatus::COMPLETED);
    }

    /**
     * Łączny szacowany koszt usług prototypu
     */
    public function getTotalServicesCostAttribute(): float
    {
        return (float) $this->services->sum('estimated_cost');
    }

    /**
     * Łączny rzeczywisty koszt usług prototypu
     */
    public function getTotalActualServicesCostAttribute(): float
    {
        return (float) $this->services->sum('actual_cost');
    }

    /**
     * Łączny koszt prototypu (materiały + usługi)
     */
    public function getTotalCostAttribute(): float
    {
        return $this->total_materials_cost + $this->total_services_cost;
    }
}


=================================================================================
FILE: app/Models/PrototypeMaterial.php
LOCATION: .//app/Models/PrototypeMaterial.php
=================================================================================

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use App\Enums\MaterialStatus;

class PrototypeMaterial extends Model
{
    protected $fillable = [
        'prototype_id',
        'assortment_id',
        'quantity',
        'unit',
        'unit_price',
        'total_cost',
        'status',
        'expected_delivery_date',
        'ordered_at',
        'received_at',
        'quantity_in_stock',
        'quantity_ordered',
        'supplier',
        'notes',
    ];

    protected $casts = [
        'quantity' => 'decimal:2',
        'unit_price' => 'decimal:2',
        'total_cost' => 'decimal:2',
        'quantity_in_stock' => 'decimal:2',
        'quantity_ordered' => 'decimal:2',
        'expected_delivery_date' => 'date',
        'ordered_at' => 'date',
        'received_at' => 'date',
        'status' => MaterialStatus::class,
    ];

    /**
     * Prototyp, do którego przypisany jest materiał
     */
    public function prototype(): BelongsTo
    {
        return $this->belongsTo(Prototype::class);
    }

    /**
     * Pozycja asortymentu (materiał z katalogu)
     */
    public function assortment(): BelongsTo
    {
        return $this->belongsTo(Assortment::class, 'assortment_id');
    }

    /**
     * Czy materiał jest w pełni dostępny
     */
    public function isFullyAvailable(): bool
    {
        return $this->status === MaterialStatus::IN_STOCK;
    }

    /**
     * Czy materiał wymaga zamówienia
     */
    public function needsOrdering(): bool
    {
        return $this->status === MaterialStatus::NOT_ORDERED;
    }

    /**
     * Oblicz koszt całkowity
     */
    public function recalculateTotalCost(): void
    {
        $this->total_cost = $this->quantity * $this->unit_price;
    }
}


=================================================================================
FILE: app/Models/PrototypeService.php
LOCATION: .//app/Models/PrototypeService.php
=================================================================================

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use App\Enums\ProductionStatus;

class PrototypeService extends Model
{
    protected $fillable = [
        'prototype_id',
        'step_number',
        'service_name',
        'workstation_id',
        'assigned_to_user_id',
        'estimated_quantity',
        'estimated_time_hours',
        'unit_price',
        'estimated_cost',
        'actual_quantity',
        'actual_time_hours',
        'actual_cost',
        'total_pause_duration_seconds',
        'status',
        'actual_start_date',
        'actual_end_date',
        'worker_notes',
    ];

    protected $casts = [
        'estimated_quantity' => 'decimal:2',
        'estimated_time_hours' => 'decimal:2',
        'unit_price' => 'decimal:2',
        'estimated_cost' => 'decimal:2',
        'actual_quantity' => 'decimal:2',
        'actual_time_hours' => 'decimal:2',
        'actual_cost' => 'decimal:2',
        'actual_start_date' => 'datetime',
        'actual_end_date' => 'datetime',
        'status' => ProductionStatus::class,
    ];

    /**
     * Prototyp, do którego należy zadanie
     */
    public function prototype(): BelongsTo
    {
        return $this->belongsTo(Prototype::class);
    }

    /**
     * Stanowisko robocze
     */
    public function workstation(): BelongsTo
    {
        return $this->belongsTo(Workstation::class);
    }

    /**
     * Przypisany pracownik
     */
    public function assignedWorker(): BelongsTo
    {
        return $this->belongsTo(User::class, 'assigned_to_user_id');
    }

    /**
     * Czy zadanie jest aktywne
     */
    public function isActive(): bool
    {
        return $this->status === ProductionStatus::IN_PROGRESS;
    }

    /**
     * Czy zadanie jest wstrzymane
     */
    public function isPaused(): bool
    {
        return $this->status === ProductionStatus::PAUSED;
    }

    /**
     * Oblicz szacowany koszt
     */
    public function recalculateEstimatedCost(): void
    {
        $this->estimated_cost = $this->estimated_quantity * $this->unit_price;
    }
}


=================================================================================
FILE: app/Models/Quotation.php
LOCATION: .//app/Models/Quotation.php
=================================================================================

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Quotation extends Model
{
    protected $fillable = [
        'variant_id',
        'version_number',
        'total_materials_cost',
        'total_services_cost',
        'total_net',
        'total_gross',
        'margin_percent',
        'is_approved',
        'approved_at',
        'approved_by_user_id',
        'notes',
    ];

    protected $casts = [
        'total_materials_cost' => 'decimal:2',
        'total_services_cost' => 'decimal:2',
        'total_net' => 'decimal:2',
        'total_gross' => 'decimal:2',
        'margin_percent' => 'decimal:2',
        'is_approved' => 'boolean',
        'approved_at' => 'datetime',
    ];

    public function variant()
    {
        return $this->belongsTo(Variant::class);
    }

    public function items()
    {
        return $this->hasMany(QuotationItem::class);
    }

    public function approvedBy()
    {
        return $this->belongsTo(User::class, 'approved_by_user_id');
    }
}


=================================================================================
FILE: app/Models/QuotationItem.php
LOCATION: .//app/Models/QuotationItem.php
=================================================================================

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class QuotationItem extends Model
{
    protected $fillable = [
        'quotation_id',
        'materials_cost',
        'services_cost',
        'subtotal',
    ];

    protected $casts = [
        'materials_cost' => 'decimal:2',
        'services_cost' => 'decimal:2',
        'subtotal' => 'decimal:2',
    ];

    public function quotation()
    {
        return $this->belongsTo(Quotation::class);
    }

    public function materials()
    {
        return $this->hasMany(QuotationItemMaterial::class);
    }

    public function services()
    {
        return $this->hasMany(QuotationItemService::class);
    }
}


=================================================================================
FILE: app/Models/QuotationItemMaterial.php
LOCATION: .//app/Models/QuotationItemMaterial.php
=================================================================================

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class QuotationItemMaterial extends Model
{
    protected $fillable = [
        'quotation_item_id',
        'assortment_item_id',
        'quantity',
        'unit',
        'unit_price',
        'total_cost',
        'notes',
    ];

    protected $casts = [
        'quantity' => 'decimal:2',
        'unit_price' => 'decimal:2',
        'total_cost' => 'decimal:2',
    ];

    public function quotationItem()
    {
        return $this->belongsTo(QuotationItem::class);
    }

    public function assortmentItem()
    {
        return $this->belongsTo(Assortment::class, 'assortment_item_id');
    }
}


=================================================================================
FILE: app/Models/QuotationItemService.php
LOCATION: .//app/Models/QuotationItemService.php
=================================================================================

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class QuotationItemService extends Model
{
    protected $fillable = [
        'quotation_item_id',
        'assortment_item_id',
        'estimated_quantity',
        'estimated_time_hours',
        'unit',
        'unit_price',
        'total_cost',
        'notes',
    ];

    protected $casts = [
        'estimated_quantity' => 'decimal:2',
        'estimated_time_hours' => 'decimal:2',
        'unit_price' => 'decimal:2',
        'total_cost' => 'decimal:2',
    ];

    public function quotationItem()
    {
        return $this->belongsTo(QuotationItem::class);
    }

    public function assortmentItem()
    {
        return $this->belongsTo(Assortment::class, 'assortment_item_id');
    }
}


=================================================================================
FILE: app/Models/ServiceTimeLog.php
LOCATION: .//app/Models/ServiceTimeLog.php
=================================================================================

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use App\Enums\EventType;

class ServiceTimeLog extends Model
{
    protected $fillable = [
        'production_service_id',
        'user_id',
        'event_type',
        'event_timestamp',
        'elapsed_seconds',
    ];

    protected $casts = [
        'event_timestamp' => 'datetime',
        'elapsed_seconds' => 'integer',
        'event_type' => EventType::class,
    ];

    public function productionService()
    {
        return $this->belongsTo(ProductionService::class);
    }

    public function user()
    {
        return $this->belongsTo(User::class);
    }
}


=================================================================================
FILE: app/Models/User.php
LOCATION: .//app/Models/User.php
=================================================================================

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
use Laravel\Sanctum\HasApiTokens;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;

use App\Enums\UserRole;

class User extends Authenticatable
{
    use HasFactory, Notifiable, HasApiTokens;

    protected $fillable = [
        'name',
        'email',
        'password',
        'role',
        'is_active',
        'pin_code',
    ];

    protected $hidden = [
        'password',
        'remember_token',
        'pin_code',
    ];

    protected function casts(): array
    {
        return [
            'email_verified_at' => 'datetime',
            'password' => 'hashed',
            'is_active' => 'boolean',
            'role' => UserRole::class,
        ];
    }

    /**
     * Stanowiska, do których przypisany jest pracownik (jako operator)
     */
    public function workstations(): BelongsToMany
    {
        return $this->belongsToMany(Workstation::class, 'workstation_operators')
            ->withPivot('is_primary')
            ->withTimestamps();
    }
}


=================================================================================
FILE: app/Models/Variant.php
LOCATION: .//app/Models/Variant.php
=================================================================================

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\HasOne;
use App\Enums\VariantType;
use App\Enums\VariantStatus;
use App\Enums\MaterialStatus;

class Variant extends Model
{
    protected $table = 'variants';

    protected $fillable = [
        'order_id',
        'parent_variant_id',
        'is_group',
        'variant_number',
        'name',
        'description',
        'quantity',
        'type',
        'status',
        'is_approved',
        'feedback_notes',
        'approved_prototype_id',
    ];

    protected $casts = [
        'is_group' => 'boolean',
        'quantity' => 'integer',
        'type' => VariantType::class,
        'status' => VariantStatus::class,
        'is_approved' => 'boolean',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
    ];

    // Relacje

    public function order(): BelongsTo
    {
        return $this->belongsTo(Order::class);
    }

    public function parentVariant(): BelongsTo
    {
        return $this->belongsTo(Variant::class, 'parent_variant_id');
    }

    public function childVariants(): HasMany
    {
        return $this->hasMany(Variant::class, 'parent_variant_id');
    }

    public function materials(): HasMany
    {
        return $this->hasMany(VariantMaterial::class);
    }

    public function quotations(): HasMany
    {
        return $this->hasMany(Quotation::class);
    }

    public function approvedQuotation(): HasOne
    {
        return $this->hasOne(Quotation::class)->where('is_approved', true);
    }

    public function prototypes(): HasMany
    {
        return $this->hasMany(Prototype::class);
    }

    public function productionOrder(): HasOne
    {
        return $this->hasOne(ProductionOrder::class);
    }

    public function deliveries(): HasMany
    {
        return $this->hasMany(Delivery::class);
    }

    // Pomocnicze

    public function isGroup(): bool
    {
        return $this->is_group === true;
    }

    public function isPrototype(): bool
    {
        return $this->type === VariantType::PROTOTYPE;
    }

    public function isSerial(): bool
    {
        return $this->type === VariantType::SERIAL;
    }

    public function isChild(): bool
    {
        return $this->parent_variant_id !== null;
    }

    /**
     * Wszyscy potomkowie rekurencyjnie — uzywane przy force delete.
     */
    public function allDescendants(): \Illuminate\Support\Collection
    {
        $descendants = collect();
        foreach ($this->childVariants as $child) {
            $descendants->push($child);
            $descendants = $descendants->merge($child->allDescendants());
        }
        return $descendants;
    }

    public function getMaterialsStatusSummaryAttribute(): array
    {
        $materials = $this->materials;
        return [
            'total' => $materials->count(),
            'not_ordered' => $materials->where('status', MaterialStatus::NOT_ORDERED)->count(),
            'ordered' => $materials->where('status', MaterialStatus::ORDERED)->count(),
            'partially_in_stock' => $materials->where('status', MaterialStatus::PARTIALLY_IN_STOCK)->count(),
            'in_stock' => $materials->where('status', MaterialStatus::IN_STOCK)->count(),
            'all_ready' => $this->allMaterialsInStock(),
        ];
    }

    public function allMaterialsInStock(): bool
    {
        if ($this->materials->isEmpty())
            return false;
        return $this->materials->every(fn($m) => $m->status === MaterialStatus::IN_STOCK);
    }

    public function getTotalMaterialsCostAttribute(): float
    {
        return (float) $this->materials->sum('total_cost');
    }
}


=================================================================================
FILE: app/Models/VariantMaterial.php
LOCATION: .//app/Models/VariantMaterial.php
=================================================================================

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use App\Enums\MaterialStatus;

class VariantMaterial extends Model
{
    protected $fillable = [
        'variant_id',
        'assortment_id',
        'quantity',
        'unit',
        'unit_price',
        'total_cost',
        'status',
        'expected_delivery_date',
        'ordered_at',
        'received_at',
        'quantity_in_stock',
        'quantity_ordered',
        'supplier',
        'notes',
    ];

    protected $casts = [
        'quantity' => 'decimal:2',
        'unit_price' => 'decimal:2',
        'total_cost' => 'decimal:2',
        'quantity_in_stock' => 'decimal:2',
        'quantity_ordered' => 'decimal:2',
        'expected_delivery_date' => 'date',
        'ordered_at' => 'date',
        'received_at' => 'date',
        'status' => MaterialStatus::class,
    ];

    /**
     * Wariant, do którego przypisany jest materiał
     */
    public function variant(): BelongsTo
    {
        return $this->belongsTo(Variant::class);
    }

    /**
     * Pozycja asortymentu (materiał z katalogu)
     */
    public function assortment(): BelongsTo
    {
        return $this->belongsTo(Assortment::class, 'assortment_id');
    }

    /**
     * Czy materiał jest w pełni dostępny
     */
    public function isFullyAvailable(): bool
    {
        return $this->status === MaterialStatus::IN_STOCK;
    }

    /**
     * Czy materiał wymaga zamówienia
     */
    public function needsOrdering(): bool
    {
        return $this->status === MaterialStatus::NOT_ORDERED;
    }

    /**
     * Oblicz koszt całkowity na podstawie ilości i ceny jednostkowej
     */
    public function recalculateTotalCost(): void
    {
        $this->total_cost = $this->quantity * $this->unit_price;
    }
}


=================================================================================
FILE: app/Models/Workstation.php
LOCATION: .//app/Models/Workstation.php
=================================================================================

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use App\Models\Assortment;
use App\Enums\WorkstationType;
use App\Enums\WorkstationStatus;

class Workstation extends Model
{
    use HasFactory;

    protected $fillable = [
        'name',
        'type',
        'status',
        'current_task_id',
        'location',
    ];

    protected $casts = [
        'type' => WorkstationType::class,
        'status' => WorkstationStatus::class,
    ];

    public function operators()
    {
        return $this->belongsToMany(User::class, 'workstation_operators')
            ->withPivot('is_primary')
            ->withTimestamps();
    }

    public function tasks()
    {
        return $this->hasMany(ProductionService::class, 'workstation_id');
    }

    public function currentTask()
    {
        return $this->belongsTo(ProductionService::class, 'current_task_id');
    }

    public function scopeAvailable($query)
    {
        return $query->where('status', WorkstationStatus::IDLE);
    }


    public function allowedServices()
    {
        return $this->belongsToMany(Assortment::class, 'assortment_workstation')
            ->where('type', \App\Enums\AssortmentType::SERVICE)
            ->withTimestamps();
    }


}


=================================================================================
FILE: app/Http/Controllers/API/AssortmentController.php
LOCATION: .//app/Http/Controllers/API/AssortmentController.php
=================================================================================

<?php

namespace App\Http\Controllers\API;

use App\Http\Controllers\Controller;
use App\Models\Assortment;
use App\Enums\AssortmentType;
use App\Enums\AssortmentUnit;
use App\Enums\AssortmentHistoryAction;
use App\Traits\Paginatable;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;
use Illuminate\Validation\Rule;

class AssortmentController extends Controller
{
    use Paginatable;

    /**
     * Lista asortymentu z paginacją server-side.
     *
     * Query params:
     *   - page, per_page, sort_by, sort_dir  → paginacja/sortowanie
     *   - search:    string (nazwa, opis)
     *   - type:      string (material|service)
     *   - category:  string
     *   - is_active: bool
     */
    public function index(Request $request)
    {
        try {
            $query = Assortment::query();

            if ($request->filled('type')) {
                $query->where('type', $request->input('type'));
            }

            if ($request->filled('category')) {
                $query->where('category', $request->input('category'));
            }

            if ($request->has('is_active')) {
                $query->where('is_active', $request->boolean('is_active'));
            }

            if ($request->filled('search')) {
                $search = $request->input('search');
                $query->where(function ($q) use ($search) {
                    $q->where('name', 'like', "%{$search}%")
                        ->orWhere('description', 'like', "%{$search}%");
                });
            }

            // Sortowanie z whitelistą
            $this->applySorting($query, $request, [
                'name',
                'category',
                'type',
                'default_price',
                'created_at',
            ], 'category', 'asc');

            // Drugie sortowanie po nazwie (w ramach kategorii)
            if ($request->get('sort_by', 'category') === 'category') {
                $query->orderBy('name', 'asc');
            }

            // Paginacja
            $items = $this->paginateQuery($query, $request, 20);

            return response()->json($items);
        } catch (\Exception $e) {
            \Log::error('Assortment index error: ' . $e->getMessage());
            return response()->json([
                'message' => 'Błąd podczas pobierania asortymentu',
                'error' => $e->getMessage()
            ], 500);
        }
    }


    public function show(Assortment $assortment)
    {
        try {
            $assortment->load(['history.user']);
            return response()->json($assortment);
        } catch (\Exception $e) {
            \Log::error('Assortment show error: ' . $e->getMessage());
            return response()->json([
                'message' => 'Błąd podczas pobierania pozycji',
                'error' => $e->getMessage()
            ], 500);
        }
    }

    public function store(Request $request)
    {
        try {
            $validated = $request->validate([
                // ✅ Walidacja z Enum
                'type' => ['required', Rule::enum(AssortmentType::class)],
                'name' => 'required|string|max:255',
                'category' => 'required|string|max:255',
                'unit' => ['required', Rule::enum(AssortmentUnit::class)],
                'default_price' => 'required|numeric|min:0',
                'description' => 'nullable|string',
                'is_active' => 'boolean',
            ]);

            $item = Assortment::create($validated);

            return response()->json($item, 201);
        } catch (\Illuminate\Validation\ValidationException $e) {
            return response()->json([
                'message' => 'Błąd walidacji',
                'errors' => $e->errors()
            ], 422);
        } catch (\Exception $e) {
            \Log::error('Assortment store error: ' . $e->getMessage());
            return response()->json([
                'message' => 'Błąd podczas tworzenia pozycji',
                'error' => $e->getMessage()
            ], 500);
        }
    }

    public function update(Request $request, Assortment $assortment)
    {
        try {
            $validated = $request->validate([
                // ✅ Walidacja z Enum (sometimes = pole opcjonalne)
                'type' => ['sometimes', Rule::enum(AssortmentType::class)],
                'name' => 'sometimes|string|max:255',
                'category' => 'sometimes|string|max:255',
                'unit' => ['sometimes', Rule::enum(AssortmentUnit::class)],
                'default_price' => 'sometimes|numeric|min:0',
                'description' => 'nullable|string',
                'is_active' => 'boolean',
            ]);

            $assortment->update($validated);

            return response()->json($assortment);
        } catch (\Illuminate\Validation\ValidationException $e) {
            return response()->json([
                'message' => 'Błąd walidacji',
                'errors' => $e->errors()
            ], 422);
        } catch (\Exception $e) {
            \Log::error('Assortment update error: ' . $e->getMessage());
            return response()->json([
                'message' => 'Błąd podczas aktualizacji pozycji',
                'error' => $e->getMessage()
            ], 500);
        }
    }


    public function destroy(Assortment $assortment)
    {
        try {
            $usageCount = DB::table('quotation_item_materials')
                ->where('assortment_item_id', $assortment->id)
                ->count();

            $usageCount += DB::table('quotation_item_services')
                ->where('assortment_item_id', $assortment->id)
                ->count();

            if ($usageCount > 0) {
                return response()->json([
                    'message' => 'Nie można usunąć pozycji, która jest używana w wycenach. Ustaw pozycję jako nieaktywną zamiast usuwania.'
                ], 400);
            }

            $assortment->delete();

            return response()->json([
                'message' => 'Pozycja usunięta pomyślnie'
            ]);
        } catch (\Exception $e) {
            \Log::error('Assortment delete error: ' . $e->getMessage());
            return response()->json([
                'message' => 'Błąd podczas usuwania pozycji',
                'error' => $e->getMessage()
            ], 500);
        }
    }

    public function materials()
    {
        $materials = Assortment::where('type', AssortmentType::MATERIAL)
            ->where('is_active', true)
            ->orderBy('category')
            ->orderBy('name')
            ->get();

        return response()->json($materials);
    }

    public function services()
    {
        $services = Assortment::where('type', AssortmentType::SERVICE)
            ->where('is_active', true)
            ->orderBy('category')
            ->orderBy('name')
            ->get();

        return response()->json($services);
    }

    public function categories(Request $request)
    {
        $type = $request->input('type');

        $query = Assortment::select('category')
            ->distinct()
            ->orderBy('category');

        if ($type) {
            $query->where('type', $type);
        }

        $categories = $query->pluck('category');

        return response()->json($categories);
    }

    public function toggleActive(Assortment $assortment)
    {
        try {
            $wasActive = $assortment->is_active;
            $assortment->is_active = !$assortment->is_active;
            $assortment->save();

            // Log używając Enuma
            $action = $assortment->is_active
                ? AssortmentHistoryAction::ACTIVATED
                : AssortmentHistoryAction::DEACTIVATED;

            $description = $assortment->is_active
                ? 'Pozycja aktywowana'
                : 'Pozycja dezaktywowana';

            $assortment->logHistory(
                $action,
                ['is_active' => $wasActive],
                ['is_active' => $assortment->is_active],
                $description
            );

            return response()->json([
                'message' => 'Status zmieniony pomyślnie',
                'item' => $assortment
            ]);
        } catch (\Exception $e) {
            \Log::error('Toggle active error: ' . $e->getMessage());
            return response()->json([
                'message' => 'Błąd podczas zmiany statusu',
                'error' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Pobierz historię zmian pozycji
     */
    public function history(Assortment $assortment)
    {
        try {
            $history = $assortment->history()
                ->with('user')
                ->orderBy('created_at', 'desc')
                ->get();

            return response()->json($history);
        } catch (\Exception $e) {
            \Log::error('History error: ' . $e->getMessage());
            return response()->json([
                'message' => 'Błąd podczas pobierania historii',
                'error' => $e->getMessage()
            ], 500);
        }
    }

    public function batchCheckOrCreate(Request $request)
    {
        $request->validate([
            'type' => ['nullable', Rule::enum(AssortmentType::class)], // NOWE: Parametr typu
            'items' => 'required|array',
            'items.*.name' => 'required|string|max:255',
            'items.*.quantity' => 'required|numeric|min:0',
            // Unit jest opcjonalny dla usług (domyślnie 'h')
            'items.*.unit' => 'nullable|string|max:10',
            'items.*.unit_price' => 'nullable|numeric|min:0',
        ]);

        $typeStr = $request->input('type', AssortmentType::MATERIAL->value);
        $assortmentType = AssortmentType::from($typeStr);

        $defaultUnit = $assortmentType === AssortmentType::SERVICE
            ? AssortmentUnit::H
            : AssortmentUnit::SZT;

        $resolvedItems = [];

        DB::transaction(function () use ($request, $assortmentType, $defaultUnit, &$resolvedItems) {
            foreach ($request->items as $itemData) {
                $importedPrice = isset($itemData['unit_price']) ? (float) $itemData['unit_price'] : null;

                // Normalizacja jednostki
                $unitStr = $itemData['unit'] ?? $defaultUnit->value;
                $unitEnum = AssortmentUnit::tryFrom(strtoupper($unitStr)) ?? $defaultUnit;

                // Znajdź lub utwórz Asortyment
                $assortment = Assortment::firstOrCreate(
                    [
                        'name' => $itemData['name'],
                        'type' => $assortmentType
                    ],
                    [
                        'category' => 'Importowane',
                        'unit' => $unitEnum,
                        'default_price' => $importedPrice ?? 0,
                        'description' => 'Utworzono automatycznie z importu',
                        'is_active' => true
                    ]
                );

                if ($assortment->default_price == 0 && $importedPrice !== null) {
                    $assortment->update(['default_price' => $importedPrice]);
                }

                $finalUnitPrice = $importedPrice ?? $assortment->default_price;

                $resolvedItems[] = [
                    'assortment_item_id' => $assortment->id,
                    'quantity' => $itemData['quantity'], // Dla usług to będzie estimated_time_hours
                    'unit' => $assortment->unit->value,
                    'unit_price' => $finalUnitPrice,
                    'assortment_details' => $assortment
                ];
            }
        });

        return response()->json($resolvedItems);
    }

}


=================================================================================
FILE: app/Http/Controllers/API/AuthController.php
LOCATION: .//app/Http/Controllers/API/AuthController.php
=================================================================================

<?php

namespace App\Http\Controllers\API;

use App\Http\Controllers\Controller;
use App\Models\User;
use App\Enums\UserRole;
use App\Http\Resources\UserResource; // Import Resource
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use Illuminate\Validation\ValidationException;

class AuthController extends Controller
{
    // Standardowe logowanie (Email + Hasło) -> Rola z bazy (np. ADMIN)
    public function login(Request $request)
    {
        $request->validate([
            'email' => 'required|email',
            'password' => 'required',
        ]);

        $user = User::where('email', $request->email)->first();

        if (!$user || !Hash::check($request->password, $user->password)) {
            throw ValidationException::withMessages([
                'email' => ['Podane dane są nieprawidłowe.'],
            ]);
        }

        // Zwykły token bez specjalnych uprawnień
        $token = $user->createToken('auth_token')->plainTextToken;

        return response()->json([
            'token' => $token,
            'user' => new UserResource($user), // Używamy Resource dla spójności
        ]);
    }

    public function logout(Request $request)
    {
        $request->user()->currentAccessToken()->delete();

        return response()->json([
            'message' => 'Wylogowano pomyślnie'
        ]);
    }

    // Pobieranie usera (np. przy odświeżaniu F5)
    public function me(Request $request)
    {
        // Resource sam sprawdzi, czy token ma flagę 'act-as-worker' i podmieni rolę
        return new UserResource($request->user());
    }

    // Logowanie PIN -> Wymuszona rola PRODUCTION_EMPLOYEE
    public function loginPin(Request $request)
    {
        $request->validate([
            'pin' => 'required|string|size:4',
        ]);

        $inputPin = $request->input('pin');

        $usersWithPin = User::where('is_active', true)
            ->whereNotNull('pin_code')
            ->get();

        $matchedUser = null;

        foreach ($usersWithPin as $user) {
            if (Hash::check($inputPin, $user->pin_code)) {
                $matchedUser = $user;
                break;
            }
        }

        if (!$matchedUser) {
            throw ValidationException::withMessages([
                'pin' => ['Nieprawidłowy kod PIN.'],
            ]);
        }

        // Token z flagą "act-as-worker"
        $token = $matchedUser->createToken('auth_token_pin', ['act-as-worker'])->plainTextToken;

        $matchedUser->role = UserRole::PRODUCTION_EMPLOYEE;

        return response()->json([
            'token' => $token,
            // UserResource sprawdzi flagę tokena (lub Requesta w tym kontekście) i podmieni rolę
            'user' => new UserResource($matchedUser),
        ]);
    }
}


=================================================================================
FILE: app/Http/Controllers/API/CustomerController.php
LOCATION: .//app/Http/Controllers/API/CustomerController.php
=================================================================================

<?php

namespace App\Http\Controllers\API;

use App\Http\Controllers\Controller;
use App\Models\Customer;
use App\Traits\Paginatable;
use Illuminate\Http\Request;
use Illuminate\Http\JsonResponse;
use Illuminate\Validation\Rule;
use Illuminate\Support\Facades\DB;

class CustomerController extends Controller
{
    use Paginatable;

    /**
     * Lista klientów z paginacją server-side.
     *
     * Query params:
     *   - page, per_page, sort_by, sort_dir  → paginacja/sortowanie
     *   - search:    string (nazwa, email, NIP, telefon, adres)
     *   - type:      string (B2B|B2C|all)
     *   - is_active: string (true|false|all) — filtr aktywności
     */
    public function index(Request $request): JsonResponse
    {
        try {
            $query = Customer::query();

            // Filtrowanie po typie klienta
            if ($request->filled('type') && $request->type !== 'all') {
                $query->where('type', $request->type);
            }

            // Filtrowanie po statusie aktywności
            if ($request->filled('is_active') && $request->input('is_active') !== 'all') {
                $query->where('is_active', $request->boolean('is_active'));
            }

            // Wyszukiwanie
            if ($request->filled('search')) {
                $search = $request->input('search');
                $query->where(function ($q) use ($search) {
                    $q->where('name', 'like', "%{$search}%")
                        ->orWhere('email', 'like', "%{$search}%")
                        ->orWhere('nip', 'like', "%{$search}%")
                        ->orWhere('phone', 'like', "%{$search}%")
                        ->orWhere('address', 'like', "%{$search}%");
                });
            }

            // Dołącz statystyki zamówień
            $query->withCount('orders');

            // Sortowanie z whitelistą
            $this->applySorting($query, $request, [
                'name',
                'email',
                'type',
                'created_at',
                'orders_count',
            ], 'name', 'asc');

            // Paginacja
            $customers = $this->paginateQuery($query, $request);

            return response()->json($customers);
        } catch (\Exception $e) {
            \Log::error('Customers index error: ' . $e->getMessage());
            return response()->json([
                'message' => 'Błąd podczas pobierania klientów',
                'error' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Utwórz nowego klienta
     */
    public function store(Request $request): JsonResponse
    {
        try {
            $validated = $request->validate([
                'name' => 'required|string|max:255',
                'type' => 'required|in:B2B,B2C',
                'nip' => 'nullable|string|max:10|unique:customers,nip',
                'email' => 'nullable|email|max:255',
                'phone' => 'nullable|string|max:20',
                'address' => 'nullable|string|max:500',
                'is_active' => 'boolean',
            ]);

            // Ustaw domyślne wartości
            $validated['is_active'] = $validated['is_active'] ?? true;

            $customer = Customer::create($validated);

            return response()->json([
                'data' => $customer,
                'message' => 'Klient utworzony pomyślnie'
            ], 201);
        } catch (\Illuminate\Validation\ValidationException $e) {
            return response()->json([
                'message' => 'Błąd walidacji',
                'errors' => $e->errors()
            ], 422);
        } catch (\Exception $e) {
            \Log::error('Customer store error: ' . $e->getMessage());
            return response()->json([
                'message' => 'Błąd podczas tworzenia klienta',
                'error' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Pobierz szczegóły klienta
     *
     * OPTYMALIZACJA (pkt 2):
     *
     * BYŁO (8 zapytań SQL):
     *   1. load(['orders' => limit(20)])     — 1 query
     *   2. loadCount('orders')               — 1 query (redundantne!)
     *   3. $customer->orders()->count()      — 1 query (to samo co #2!)
     *   4. ->whereNotIn(...)->count()        — 1 query
     *   5. ->where('completed')->count()     — 1 query
     *   6. ->where('cancelled')->count()     — 1 query
     *   7. ->where('paid')->count()          — 1 query
     *   8. ->whereIn('unpaid','partial')     — 1 query
     *
     * JEST (1 zapytanie SQL):
     *   1. load(['orders']) — ładujemy WSZYSTKIE zamówienia (lekki select, bez limitu)
     *   2. Statystyki liczymy z kolekcji w PHP (0 dodatkowych query)
     *   3. Do frontendu wysyłamy tylko ostatnie 20 (setRelation → slice kolekcji)
     *
     * Klient w systemie MES ma zwykle dziesiątki/setki zamówień — załadowanie
     * lekkiego selecta jest tańsze niż 8 osobnych roundtripów do bazy.
     */
    public function show(Customer $customer): JsonResponse
    {
        try {
            // ── 1 query: załaduj WSZYSTKIE zamówienia (lekkie kolumny) ──
            $customer->load([
                'orders' => function ($query) {
                    $query->select(
                        'id',
                        'customer_id',
                        'order_number',
                        'series',
                        'description',
                        'overall_status',
                        'payment_status',
                        'created_at'
                    )->orderBy('created_at', 'desc');
                }
            ]);

            // ── 0 query: oblicz statystyki z załadowanej kolekcji ──
            $allOrders = $customer->orders;

            $stats = [
                'total_orders' => $allOrders->count(),
                'active_orders' => $allOrders->whereNotIn('overall_status', ['completed', 'cancelled'])->count(),
                'completed_orders' => $allOrders->where('overall_status', 'completed')->count(),
                'cancelled_orders' => $allOrders->where('overall_status', 'cancelled')->count(),
                'paid_orders' => $allOrders->where('payment_status', 'paid')->count(),
                'unpaid_orders' => $allOrders->whereIn('payment_status', ['unpaid', 'partial'])->count(),
            ];

            $customer->stats = $stats;

            // ── Podmień relację na ostatnie 20 (frontend nie potrzebuje setek) ──
            $customer->setRelation('orders', $allOrders->take(20)->values());

            return response()->json([
                'data' => $customer,
                'message' => 'Dane klienta pobrane pomyślnie'
            ]);
        } catch (\Exception $e) {
            \Log::error('Customer show error: ' . $e->getMessage());
            return response()->json([
                'message' => 'Błąd podczas pobierania klienta',
                'error' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Aktualizuj dane klienta
     */
    public function update(Request $request, Customer $customer): JsonResponse
    {
        try {
            $validated = $request->validate([
                'name' => 'sometimes|required|string|max:255',
                'type' => 'sometimes|required|in:B2B,B2C',
                'nip' => [
                    'nullable',
                    'string',
                    'max:10',
                    Rule::unique('customers', 'nip')->ignore($customer->id)
                ],
                'email' => 'nullable|email|max:255',
                'phone' => 'nullable|string|max:20',
                'address' => 'nullable|string|max:500',
                'is_active' => 'boolean',
            ]);

            $customer->update($validated);

            return response()->json([
                'data' => $customer->fresh(),
                'message' => 'Dane klienta zaktualizowane pomyślnie'
            ]);
        } catch (\Illuminate\Validation\ValidationException $e) {
            return response()->json([
                'message' => 'Błąd walidacji',
                'errors' => $e->errors()
            ], 422);
        } catch (\Exception $e) {
            \Log::error('Customer update error: ' . $e->getMessage());
            return response()->json([
                'message' => 'Błąd podczas aktualizacji klienta',
                'error' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Usuń klienta
     */
    public function destroy(Customer $customer): JsonResponse
    {
        try {
            // Sprawdź czy klient ma zamówienia
            if ($customer->orders()->exists()) {
                return response()->json([
                    'message' => 'Nie można usunąć klienta z przypisanymi zamówieniami. Dezaktywuj klienta zamiast usuwać.'
                ], 422);
            }

            $customer->delete();

            return response()->json([
                'message' => 'Klient usunięty pomyślnie'
            ]);
        } catch (\Exception $e) {
            \Log::error('Customer destroy error: ' . $e->getMessage());
            return response()->json([
                'message' => 'Błąd podczas usuwania klienta',
                'error' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Przełącz status aktywności klienta
     */
    public function toggleActive(Customer $customer): JsonResponse
    {
        try {
            $customer->update([
                'is_active' => !$customer->is_active
            ]);

            return response()->json([
                'data' => $customer->fresh(),
                'message' => $customer->is_active
                    ? 'Klient aktywowany pomyślnie'
                    : 'Klient dezaktywowany pomyślnie'
            ]);
        } catch (\Exception $e) {
            \Log::error('Customer toggle active error: ' . $e->getMessage());
            return response()->json([
                'message' => 'Błąd podczas zmiany statusu klienta',
                'error' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Pobierz statystyki klienta
     *
     * OPTYMALIZACJA (pkt 1): 1 zapytanie SQL zamiast ~15
     *
     * Tutaj NIE ładujemy zamówień do pamięci — ten endpoint służy wyłącznie
     * do statystyk, więc zagregowany SQL jest optymalny (baza policzy szybciej
     * niż PHP, a nie transferujemy niepotrzebnych danych).
     */
    public function statistics(Customer $customer): JsonResponse
    {
        try {
            $row = DB::table('orders')
                ->where('customer_id', $customer->id)
                ->selectRaw('
                    COUNT(*) as total_orders,

                    COUNT(CASE WHEN overall_status = ? THEN 1 END) as status_draft,
                    COUNT(CASE WHEN overall_status = ? THEN 1 END) as status_quotation,
                    COUNT(CASE WHEN overall_status = ? THEN 1 END) as status_prototype,
                    COUNT(CASE WHEN overall_status = ? THEN 1 END) as status_production,
                    COUNT(CASE WHEN overall_status = ? THEN 1 END) as status_delivery,
                    COUNT(CASE WHEN overall_status = ? THEN 1 END) as status_completed,
                    COUNT(CASE WHEN overall_status = ? THEN 1 END) as status_cancelled,

                    COUNT(CASE WHEN payment_status = ? THEN 1 END) as payment_paid,
                    COUNT(CASE WHEN payment_status = ? THEN 1 END) as payment_partial,
                    COUNT(CASE WHEN payment_status = ? THEN 1 END) as payment_unpaid,
                    COUNT(CASE WHEN payment_status = ? THEN 1 END) as payment_overdue,

                    MIN(created_at) as first_order_date,
                    MAX(created_at) as last_order_date
                ', [
                    'draft',
                    'quotation',
                    'prototype',
                    'production',
                    'delivery',
                    'completed',
                    'cancelled',
                    'paid',
                    'partial',
                    'unpaid',
                    'overdue',
                ])
                ->first();

            $stats = [
                'total_orders' => (int) $row->total_orders,
                'orders_by_status' => [
                    'brief' => (int) $row->status_draft,
                    'quotation' => (int) $row->status_quotation,
                    'prototype' => (int) $row->status_prototype,
                    'production' => (int) $row->status_production,
                    'delivery' => (int) $row->status_delivery,
                    'completed' => (int) $row->status_completed,
                    'cancelled' => (int) $row->status_cancelled,
                ],
                'payment_stats' => [
                    'paid' => (int) $row->payment_paid,
                    'partial' => (int) $row->payment_partial,
                    'unpaid' => (int) $row->payment_unpaid,
                    'overdue' => (int) $row->payment_overdue,
                ],
                'first_order_date' => $row->first_order_date,
                'last_order_date' => $row->last_order_date,
            ];

            return response()->json([
                'data' => $stats,
                'message' => 'Statystyki klienta pobrane pomyślnie'
            ]);
        } catch (\Exception $e) {
            \Log::error('Customer statistics error: ' . $e->getMessage());
            return response()->json([
                'message' => 'Błąd podczas pobierania statystyk',
                'error' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Pobierz listę klientów do selecta (uproszczona)
     */
    public function forSelect(): JsonResponse
    {
        try {
            $customers = Customer::where('is_active', true)
                ->orderBy('name')
                ->select('id', 'name', 'type', 'nip', 'email')
                ->get();

            return response()->json($customers);
        } catch (\Exception $e) {
            \Log::error('Customers forSelect error: ' . $e->getMessage());
            return response()->json([
                'message' => 'Błąd podczas pobierania klientów',
                'error' => $e->getMessage()
            ], 500);
        }
    }
}


=================================================================================
FILE: app/Http/Controllers/API/MetadataController.php
LOCATION: .//app/Http/Controllers/API/MetadataController.php
=================================================================================

<?php

namespace App\Http\Controllers\API;

use App\Http\Controllers\Controller;
use App\Enums\VariantType;
use App\Enums\VariantStatus;
use App\Enums\{
    UserRole,
    CustomerType,
    AssortmentType,
    AssortmentUnit,
    OrderOverallStatus,
    PaymentStatus,
    WorkstationType,
    WorkstationStatus,
    ProductionStatus,
    OrderPriority,
    TestResult,
    DeliveryStatus,
    InvoiceStatus,
    PaymentMethod,
    EventType,
    AssortmentHistoryAction,
    MaterialStatus,
};
use App\Models\Assortment;

class MetadataController extends Controller
{
    public function index()
    {
        $map = fn($enumClass) => collect($enumClass::cases())->map(fn($e) => [
            'value' => $e->value,
            'label' => $e->label(),
        ]);

        $mapWithColor = fn($enumClass) => collect($enumClass::cases())->map(fn($e) => [
            'value' => $e->value,
            'label' => $e->label(),
            'color' => method_exists($e, 'color') ? $e->color() : null,
        ]);

        $mapFull = fn($enumClass) => collect($enumClass::cases())->map(fn($e) => [
            'value' => $e->value,
            'label' => $e->label(),
            'color' => method_exists($e, 'color') ? $e->color() : null,
            'icon' => method_exists($e, 'icon') ? $e->icon() : null,
        ]);

        return response()->json([
            // NOWE: Metadata dla wariantów
            'variant_types' => $mapWithColor(VariantType::class),
            'variant_statuses' => $mapFull(VariantStatus::class),

            'user_roles' => $map(UserRole::class),
            'customer_types' => $map(CustomerType::class),
            'assortment_types' => $map(AssortmentType::class),
            'units' => $map(AssortmentUnit::class),
            'order_statuses' => $mapFull(OrderOverallStatus::class),
            'payment_statuses' => $mapFull(PaymentStatus::class),
            'order_priorities' => $mapWithColor(OrderPriority::class),
            'workstation_types' => $map(WorkstationType::class),
            'workstation_statuses' => $mapWithColor(WorkstationStatus::class),
            'production_statuses' => $map(ProductionStatus::class),
            'test_results' => $mapWithColor(TestResult::class),
            'event_types' => $map(EventType::class),
            'material_statuses' => $mapFull(MaterialStatus::class),
            'delivery_statuses' => $mapWithColor(DeliveryStatus::class),
            'invoice_statuses' => $mapWithColor(InvoiceStatus::class),
            'payment_methods' => $map(PaymentMethod::class),
            'assortment_history_actions' => $map(AssortmentHistoryAction::class),
            'assortment_categories' => Assortment::distinct()
                ->whereNotNull('category')
                ->pluck('category')
                ->sort()
                ->values(),
        ]);
    }
}


=================================================================================
FILE: app/Http/Controllers/API/NipController.php
LOCATION: .//app/Http/Controllers/API/NipController.php
=================================================================================

<?php

namespace App\Http\Controllers\API;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Cache;

/**
 * NipController - Pobieranie danych firmy po NIP
 *
 * Używa API Białej Listy VAT Ministerstwa Finansów
 * https://www.podatki.gov.pl/wykaz-podatnikow-vat-wyszukiwarka
 */
class NipController extends Controller
{
    /**
     * Pobierz dane firmy po numerze NIP
     *
     * @param string $nip - numer NIP (10 cyfr)
     * @return \Illuminate\Http\JsonResponse
     */
    public function lookup(string $nip)
    {
        // Walidacja NIP - usuń myślniki i spacje
        $nip = preg_replace('/[^0-9]/', '', $nip);

        if (strlen($nip) !== 10) {
            return response()->json([
                'success' => false,
                'message' => 'NIP musi mieć 10 cyfr'
            ], 422);
        }

        // Walidacja sumy kontrolnej NIP
        if (!$this->validateNip($nip)) {
            return response()->json([
                'success' => false,
                'message' => 'Nieprawidłowy numer NIP'
            ], 422);
        }

        // Cache na 24h - żeby nie bombardować API
        $cacheKey = 'nip_' . $nip;

        if (Cache::has($cacheKey)) {
            return response()->json(Cache::get($cacheKey));
        }

        try {
            // API Białej Listy VAT - Ministerstwo Finansów
            $date = date('Y-m-d');
            $url = "https://wl-api.mf.gov.pl/api/search/nip/{$nip}?date={$date}";

            $response = Http::timeout(10)->get($url);

            if ($response->successful()) {
                $data = $response->json();

                if (isset($data['result']['subject']) && $data['result']['subject'] !== null) {
                    $subject = $data['result']['subject'];

                    $result = [
                        'success' => true,
                        'data' => [
                            'name' => $subject['name'] ?? '',
                            'nip' => $subject['nip'] ?? $nip,
                            'regon' => $subject['regon'] ?? '',
                            'address' => $this->formatAddress($subject),
                            'working_address' => $subject['workingAddress'] ?? '',
                            'krs' => $subject['krs'] ?? '',
                            'status_vat' => $subject['statusVat'] ?? '',
                            'account_numbers' => $subject['accountNumbers'] ?? [],
                        ]
                    ];

                    // Cache na 24h
                    Cache::put($cacheKey, $result, now()->addHours(24));

                    return response()->json($result);
                } else {
                    return response()->json([
                        'success' => false,
                        'message' => 'Nie znaleziono firmy o podanym NIP'
                    ], 404);
                }
            }

            return response()->json([
                'success' => false,
                'message' => 'Błąd połączenia z API Ministerstwa Finansów'
            ], 503);

        } catch (\Exception $e) {
            \Log::error('NIP lookup error: ' . $e->getMessage());

            return response()->json([
                'success' => false,
                'message' => 'Błąd podczas sprawdzania NIP: ' . $e->getMessage()
            ], 500);
        }
    }

    /**
     * Formatuj adres z danych API
     */
    private function formatAddress(array $subject): string
    {
        // API zwraca różne warianty adresu
        if (!empty($subject['workingAddress'])) {
            return $subject['workingAddress'];
        }

        if (!empty($subject['residenceAddress'])) {
            return $subject['residenceAddress'];
        }

        return '';
    }

    /**
     * Walidacja sumy kontrolnej NIP
     */
    private function validateNip(string $nip): bool
    {
        if (strlen($nip) !== 10) {
            return false;
        }

        $weights = [6, 5, 7, 2, 3, 4, 5, 6, 7];
        $sum = 0;

        for ($i = 0; $i < 9; $i++) {
            $sum += $weights[$i] * (int) $nip[$i];
        }

        $checksum = $sum % 11;

        // Checksum nie może być 10
        if ($checksum === 10) {
            return false;
        }

        return $checksum === (int) $nip[9];
    }
}


=================================================================================
FILE: app/Http/Controllers/API/OrderController.php
LOCATION: .//app/Http/Controllers/API/OrderController.php
=================================================================================

<?php

namespace App\Http\Controllers\API;

use App\Http\Controllers\Controller;
use App\Models\Order;
use App\Traits\Paginatable;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;
use App\Enums\ProductionStatus;
use App\Enums\PaymentStatus;
use App\Enums\OrderOverallStatus;
use App\Enums\OrderPriority;
use Illuminate\Validation\Rule;

class OrderController extends Controller
{
    use Paginatable;

    // =========================================================================
    // NUMER ZAMÓWIENIA
    // =========================================================================

    /**
     * Zwraca następny wolny numer zamówienia (podgląd).
     * Używany przez frontend do wyświetlenia info — nie rezerwuje numeru.
     *
     * GET /api/orders/next-number
     */
    public function nextNumber()
    {
        $maxNumber = Order::max('order_number');
        $next = $maxNumber ? intval($maxNumber) + 1 : 1000;
        $formatted = str_pad((string) $next, 4, '0', STR_PAD_LEFT);

        return response()->json(['next_number' => $formatted]);
    }

    // =========================================================================
    // LISTA ZAMÓWIEŃ
    // =========================================================================

    /**
     * Lista zamówień z paginacją server-side.
     *
     * Query params:
     *   - page:         int    (domyślnie 1)
     *   - per_page:     int    (domyślnie 15, max 100)
     *   - sort_by:      string (created_at | order_number | planned_delivery_date | overall_status)
     *   - sort_dir:     string (asc | desc, domyślnie desc)
     *   - search:       string (szuka w order_number, description, customer.name)
     *   - status:       string (filtruje overall_status)
     *   - quick_filter: string (active | completed | all)
     *
     * GET /api/orders
     */
    public function index(Request $request)
    {
        try {
            $query = Order::with(['customer', 'variants']);

            // Filtr statusu
            if ($request->filled('status') && $request->input('status') !== 'all') {
                $query->where('overall_status', $request->input('status'));
            }

            // Quick filter (aktywne/zakończone)
            if ($request->filled('quick_filter')) {
                $quickFilter = $request->input('quick_filter');

                if ($quickFilter === 'active') {
                    $query->whereIn('overall_status', [
                        'draft',
                        'quotation',
                        'prototype',
                        'production',
                        'delivery',
                        'DRAFT',
                        'QUOTATION',
                        'PROTOTYPE',
                        'PRODUCTION',
                        'DELIVERY',
                    ]);
                } elseif ($quickFilter === 'completed') {
                    $query->whereIn('overall_status', [
                        'completed',
                        'cancelled',
                        'COMPLETED',
                        'CANCELLED',
                    ]);
                }
                // 'all' — brak dodatkowego filtra
            }

            // Wyszukiwanie
            if ($request->filled('search')) {
                $search = $request->input('search');
                $query->where(function ($q) use ($search) {
                    $q->where('order_number', 'like', "%{$search}%")
                        ->orWhere('description', 'like', "%{$search}%")
                        ->orWhereHas('customer', function ($q) use ($search) {
                            $q->where('name', 'like', "%{$search}%");
                        });
                });
            }

            // Sortowanie z whitelistą kolumn
            $this->applySorting($query, $request, [
                'created_at',
                'order_number',
                'planned_delivery_date',
                'overall_status',
            ], 'created_at', 'desc');

            // Paginacja
            $orders = $this->paginateQuery($query, $request);

            return response()->json($orders);
        } catch (\Exception $e) {
            \Log::error('Orders index error: ' . $e->getMessage());
            return response()->json([
                'message' => 'Błąd podczas pobierania zamówień',
                'error' => $e->getMessage()
            ], 500);
        }
    }

    // =========================================================================
    // SZCZEGÓŁY ZAMÓWIENIA
    // =========================================================================

    /**
     * Szczegóły zamówienia z wariantami, prototypami i wycenami.
     *
     * GET /api/orders/{order}
     */
    public function show(Order $order)
    {
        try {
            $order->load([
                'customer',
                'variants.prototypes',
                'variants.productionOrder',
                'variants.approvedQuotation',
                'images'
            ]);

            return response()->json($order);
        } catch (\Exception $e) {
            \Log::error('Order show error: ' . $e->getMessage());
            return response()->json([
                'message' => 'Błąd podczas pobierania zamówienia',
                'error' => $e->getMessage()
            ], 500);
        }
    }

    // =========================================================================
    // TWORZENIE NOWEGO ZAMÓWIENIA
    // =========================================================================

    /**
     * Utwórz nowe zamówienie.
     *
     * Numer zamówienia (order_number) jest ZAWSZE generowany przez serwer —
     * user go nie podaje. Serwer bierze max(order_number) + 1.
     * Nowe zamówienie dostaje serię 0001.
     *
     * Przykład:
     *   Ostatni order_number w bazie: 1005
     *   Nowe zamówienie: order_number=1006, series=0001 → Z/1006/0001
     *
     * Body:
     * {
     *   "customer_id":           1,           (wymagane)
     *   "description":           "...",        (wymagane)
     *   "planned_delivery_date": "2025-12-01", (wymagane)
     *   "priority":              "normal"      (opcjonalne, domyślnie "normal")
     * }
     *
     * POST /api/orders
     */
    public function store(Request $request)
    {
        try {
            $validated = $request->validate([
                'customer_id' => 'required|exists:customers,id',
                'description' => 'required|string',
                'planned_delivery_date' => 'required|date',
                'priority' => ['nullable', Rule::enum(OrderPriority::class)],
            ]);

            DB::beginTransaction();

            // Serwer generuje kolejny numer zamówienia — user nie ma wpływu
            $maxNumber = Order::max('order_number');
            $nextNumber = $maxNumber ? intval($maxNumber) + 1 : 1000;
            $orderNumber = str_pad((string) $nextNumber, 4, '0', STR_PAD_LEFT);

            // Pierwsze zamówienie z tym numerem → seria 0001
            $series = Order::generateSeries($orderNumber);

            $order = Order::create([
                'customer_id' => $validated['customer_id'],
                'order_number' => $orderNumber,
                'series' => $series,
                'description' => $validated['description'],
                'planned_delivery_date' => $validated['planned_delivery_date'],
                'priority' => $validated['priority'] ?? OrderPriority::NORMAL,
                'overall_status' => OrderOverallStatus::DRAFT,       // Nowe zamówienie startuje jako DRAFT
                'payment_status' => PaymentStatus::UNPAID,
            ]);

            DB::commit();

            $order->load('customer');

            return response()->json($order, 201);

        } catch (\Illuminate\Validation\ValidationException $e) {
            DB::rollBack();
            return response()->json([
                'message' => 'Błąd walidacji',
                'errors' => $e->errors()
            ], 422);
        } catch (\Exception $e) {
            DB::rollBack();
            \Log::error('Order store error: ' . $e->getMessage());
            return response()->json([
                'message' => 'Błąd podczas tworzenia zamówienia',
                'error' => $e->getMessage()
            ], 500);
        }
    }

    // =========================================================================
    // AKTUALIZACJA ZAMÓWIENIA
    // =========================================================================

    /**
     * Aktualizuj dane zamówienia.
     * Nie można zmieniać order_number ani series przez ten endpoint.
     *
     * PUT /api/orders/{order}
     */
    public function update(Request $request, Order $order)
    {
        try {
            $validated = $request->validate([
                'customer_id' => 'sometimes|exists:customers,id',
                'description' => 'sometimes|string',
                'planned_delivery_date' => 'sometimes|date',
                'priority' => 'sometimes|string|in:low,normal,high,urgent',
                'overall_status' => 'sometimes|string',
            ]);

            // order_number i series są niezmieniane — integralność danych
            $order->update($validated);
            $order->load('customer');

            return response()->json($order);

        } catch (\Illuminate\Validation\ValidationException $e) {
            return response()->json([
                'message' => 'Błąd walidacji',
                'errors' => $e->errors()
            ], 422);
        } catch (\Exception $e) {
            \Log::error('Order update error: ' . $e->getMessage());
            return response()->json([
                'message' => 'Błąd podczas aktualizacji zamówienia',
                'error' => $e->getMessage()
            ], 500);
        }
    }

    // =========================================================================
    // USUWANIE ZAMÓWIENIA
    // =========================================================================

    /**
     * Usuń zamówienie.
     * Dozwolone tylko w statusie draft lub quotation (brak aktywnej produkcji).
     *
     * DELETE /api/orders/{order}
     */
    public function destroy(Order $order)
    {
        try {
            if (!in_array($order->overall_status->value ?? $order->overall_status, ['draft', 'quotation'])) {
                return response()->json([
                    'message' => 'Można usunąć tylko zamówienia w fazie szkicu lub wyceny'
                ], 403);
            }

            $orderNumber = $order->full_order_number;
            $order->delete();

            return response()->json([
                'message' => "Zamówienie {$orderNumber} usunięte pomyślnie"
            ]);
        } catch (\Exception $e) {
            \Log::error('Order delete error: ' . $e->getMessage());
            return response()->json([
                'message' => 'Błąd podczas usuwania zamówienia',
                'error' => $e->getMessage()
            ], 500);
        }
    }

    // =========================================================================
    // PODSUMOWANIE FINANSOWE
    // =========================================================================

    /**
     * Pełne podsumowanie finansowe zamówienia:
     *  - Suma zatwierdzonych wycen (netto/brutto) per wariant i łącznie
     *  - Rzeczywiste koszty usług z produkcji
     *  - Rzeczywiste koszty materiałów
     *  - Wariancja całkowita
     *
     * GET /api/orders/{order}/financial-summary
     */
    public function financialSummary(Order $order)
    {
        try {
            $order->load([
                'variants.approvedQuotation',
                'variants.productionOrder.services',
            ]);

            $variantsSummary = [];
            $totalApprovedNet = 0.0;
            $totalApprovedGross = 0.0;
            $totalApprovedMat = 0.0;
            $totalApprovedSvc = 0.0;
            $totalActualMat = 0.0;
            $totalActualSvc = 0.0;

            foreach ($order->variants as $variant) {
                $approvedQ = $variant->approvedQuotation;

                $approvedNet = $approvedQ ? (float) $approvedQ->total_net : 0.0;
                $approvedGross = $approvedQ ? (float) $approvedQ->total_gross : 0.0;
                $approvedMat = $approvedQ ? (float) $approvedQ->total_materials_cost : 0.0;
                $approvedSvc = $approvedQ ? (float) $approvedQ->total_services_cost : 0.0;

                // Koszty rzeczywiste materiałów — bezpośrednie zapytanie (brak błędów z castami)
                $actualMat = (float) \App\Models\VariantMaterial::where('variant_id', $variant->id)
                    ->sum('total_cost');

                // Koszty rzeczywiste usług — tylko COMPLETED i IN_PROGRESS
                $actualSvc = 0.0;
                if ($variant->productionOrder) {
                    $actualSvc = (float) \App\Models\ProductionService::where('production_order_id', $variant->productionOrder->id)
                        ->whereIn('status', [
                            ProductionStatus::COMPLETED->value,
                            ProductionStatus::IN_PROGRESS->value,
                        ])
                        ->whereNotNull('actual_cost')
                        ->sum('actual_cost');
                }

                $variantsSummary[] = [
                    'variant_id' => $variant->id,
                    'variant_number' => $variant->variant_number,
                    'variant_name' => $variant->name,
                    'has_approved_quotation' => (bool) $approvedQ,
                    'approved_net' => round($approvedNet, 2),
                    'approved_gross' => round($approvedGross, 2),
                    'approved_materials_cost' => round($approvedMat, 2),
                    'approved_services_cost' => round($approvedSvc, 2),
                    'actual_materials_cost' => round($actualMat, 2),
                    'actual_services_cost' => round($actualSvc, 2),
                    'actual_total' => round($actualMat + $actualSvc, 2),
                    'variance' => round(($actualMat + $actualSvc) - $approvedGross, 2),
                ];

                $totalApprovedNet += $approvedNet;
                $totalApprovedGross += $approvedGross;
                $totalApprovedMat += $approvedMat;
                $totalApprovedSvc += $approvedSvc;
                $totalActualMat += $actualMat;
                $totalActualSvc += $actualSvc;
            }

            $totalActual = $totalActualMat + $totalActualSvc;
            $totalVariance = $totalActual - $totalApprovedGross;

            return response()->json([
                'order_id' => $order->id,
                'order_number' => $order->full_order_number,

                'total_approved_net' => round($totalApprovedNet, 2),
                'total_approved_gross' => round($totalApprovedGross, 2),
                'total_approved_materials' => round($totalApprovedMat, 2),
                'total_approved_services' => round($totalApprovedSvc, 2),

                'total_actual_materials' => round($totalActualMat, 2),
                'total_actual_services' => round($totalActualSvc, 2),
                'total_actual' => round($totalActual, 2),

                'total_variance' => round($totalVariance, 2),
                'variance_percent' => $totalApprovedGross > 0
                    ? round(($totalVariance / $totalApprovedGross) * 100, 2)
                    : null,

                'variants' => $variantsSummary,
            ]);

        } catch (\Exception $e) {
            \Log::error('Order financial summary error: ' . $e->getMessage());
            return response()->json([
                'message' => 'Błąd podczas pobierania podsumowania finansowego',
                'error' => $e->getMessage()
            ], 500);
        }
    }
}


=================================================================================
FILE: app/Http/Controllers/API/OrderImageController.php
LOCATION: .//app/Http/Controllers/API/OrderImageController.php
=================================================================================

<?php

namespace App\Http\Controllers\API;

use App\Http\Controllers\Controller;
use App\Models\Order;
use App\Models\OrderImage;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Storage;
use Intervention\Image\Facades\Image;

class OrderImageController extends Controller
{
    /**
     * Pobierz wszystkie zdjęcia zamówienia
     */
    public function index(Order $order)
    {
        $images = $order->images()
            ->orderBy('sort_order')
            ->get();
            
        return response()->json($images);
    }

    /**
     * Prześlij nowe zdjęcia
     */
    public function store(Request $request, Order $order)
    {
        $request->validate([
            'images' => 'required|array',
            'images.*' => 'required|image|max:5120', // max 5MB
            'description' => 'nullable|string'
        ]);

        $uploadedImages = [];
        $maxSortOrder = $order->images()->max('sort_order') ?? 0;

        foreach ($request->file('images') as $index => $file) {
            // Generuj unikalną nazwę
            $filename = time() . '_' . $index . '.' . $file->getClientOriginalExtension();
            
            // Zapisz główne zdjęcie
            $path = $file->storeAs('orders/' . $order->id . '/images', $filename, 'public');
            
            // Wygeneruj thumbnail (200x200)
            $thumbnailPath = 'orders/' . $order->id . '/thumbnails/' . $filename;
            $thumbnail = Image::make($file)
                ->fit(200, 200)
                ->encode();
            Storage::disk('public')->put($thumbnailPath, $thumbnail);

            // Utwórz rekord w bazie
            $image = $order->images()->create([
                'filename' => $file->getClientOriginalName(),
                'path' => $path,
                'thumbnail_path' => $thumbnailPath,
                'mime_type' => $file->getMimeType(),
                'size' => $file->getSize(),
                'description' => $request->input('description'),
                'sort_order' => $maxSortOrder + $index + 1
            ]);

            $uploadedImages[] = $image;
        }

        return response()->json([
            'message' => 'Zdjęcia przesłane pomyślnie',
            'images' => $uploadedImages
        ], 201);
    }

    /**
     * Usuń zdjęcie
     */
    public function destroy(Order $order, OrderImage $image)
    {
        // Sprawdź czy zdjęcie należy do zamówienia
        if ($image->order_id !== $order->id) {
            return response()->json([
                'message' => 'Zdjęcie nie należy do tego zamówienia'
            ], 403);
        }

        // Usuń pliki z dysku
        Storage::disk('public')->delete($image->path);
        if ($image->thumbnail_path) {
            Storage::disk('public')->delete($image->thumbnail_path);
        }

        // Usuń rekord z bazy
        $image->delete();

        return response()->json([
            'message' => 'Zdjęcie usunięte pomyślnie'
        ]);
    }

    /**
     * Zaktualizuj kolejność zdjęć
     */
    public function updateOrder(Request $request, Order $order)
    {
        $request->validate([
            'images' => 'required|array',
            'images.*.id' => 'required|exists:order_images,id',
            'images.*.sort_order' => 'required|integer'
        ]);

        foreach ($request->input('images') as $imageData) {
            OrderImage::where('id', $imageData['id'])
                ->where('order_id', $order->id)
                ->update(['sort_order' => $imageData['sort_order']]);
        }

        return response()->json([
            'message' => 'Kolejność zaktualizowana'
        ]);
    }
}


=================================================================================
FILE: app/Http/Controllers/API/OrderSeriesController.php
LOCATION: .//app/Http/Controllers/API/OrderSeriesController.php
=================================================================================

<?php

namespace App\Http\Controllers\API;

use App\Http\Controllers\Controller;
use App\Models\Order;
use App\Models\Variant;
use App\Services\SeriesService;
use Illuminate\Http\Request;
use Illuminate\Http\JsonResponse;
use Illuminate\Support\Facades\Log;

/**
 * OrderSeriesController — zarządzanie seriami zamówień
 *
 * Seria = kolejne uruchomienie produkcji dla tego samego numeru zamówienia.
 *
 * Endpointy:
 *   GET  /api/orders/{order}/series          → lista wszystkich serii dla order_number
 *   GET  /api/orders/{order}/series/variants  → warianty z serii do selektora kopiowania
 *   POST /api/orders/{order}/series/create    → utwórz nową serię (pusta lub z kopiowaniem)
 */
class OrderSeriesController extends Controller
{
    public function __construct(
        protected SeriesService $seriesService
    ) {
    }

    // =========================================================================
    // LISTA SERII
    // =========================================================================

    /**
     * Pobierz wszystkie serie dla danego numeru zamówienia.
     *
     * Wejście: dowolne zamówienie z tego samego order_number.
     * Wyjście: lista wszystkich serii (Z/0001/0001, Z/0001/0002, ...),
     *          posortowana rosnąco.
     *
     * GET /api/orders/{order}/series
     */
    public function index(Order $order): JsonResponse
    {
        try {
            $series = $this->seriesService->getAllSeriesForOrderNumber($order->order_number);

            return response()->json([
                'order_number' => $order->order_number,
                'data' => $series,
                'count' => $series->count(),
            ]);
        } catch (\Exception $e) {
            Log::error("OrderSeriesController::index error: {$e->getMessage()}");
            return response()->json([
                'message' => 'Błąd podczas pobierania serii zamówienia',
                'error' => $e->getMessage(),
            ], 500);
        }
    }

    // =========================================================================
    // SELEKTOR WARIANTÓW DO KOPIOWANIA
    // =========================================================================

    /**
     * Pobierz warianty z danej serii do wyświetlenia w selektorze kopiowania.
     *
     * Zwraca warianty z informacją:
     *  - czy mają wycenę (zatwierdzoną lub nie)
     *  - czy mają materiały
     *  - podstawowe dane (nazwa, ilość, status)
     *
     * GET /api/orders/{order}/series/variants
     */
    public function variantsForSelector(Order $order): JsonResponse
    {
        try {
            $variants = $this->seriesService->getVariantsForCopySelector($order);

            return response()->json([
                'order_id' => $order->id,
                'full_order_number' => $order->full_order_number,
                'data' => $variants,
            ]);
        } catch (\Exception $e) {
            Log::error("OrderSeriesController::variantsForSelector error: {$e->getMessage()}");
            return response()->json([
                'message' => 'Błąd podczas pobierania wariantów do selektora',
                'error' => $e->getMessage(),
            ], 500);
        }
    }

    // =========================================================================
    // TWORZENIE NOWEJ SERII
    // =========================================================================

    /**
     * Utwórz nową serię dla zamówienia.
     *
     * Tryby działania:
     *
     * 1. PUSTA SERIA (bez copy_from_order_id lub bez variants):
     *    {
     *      "description":           "Seria letnia 2025",
     *      "planned_delivery_date": "2025-08-01",
     *      "priority":              "high"
     *    }
     *
     * 2. SERIA Z KOPIOWANIEM WARIANTÓW:
     *    {
     *      "description":            "Seria Q3 2025",
     *      "planned_delivery_date":  "2025-09-15",
     *      "copy_from_order_id":     42,      ← ID serii źródłowej (musi mieć ten sam order_number)
     *      "variants": [
     *        {
     *          "source_variant_id": 5,
     *          "copy_quotation":    true,    ← kopiuj wycenę (zatwierdzoną lub najnowszą)
     *          "copy_materials":    false    ← kopiuj materiały wariantu
     *        },
     *        {
     *          "source_variant_id": 7,
     *          "copy_quotation":    true,
     *          "copy_materials":    true
     *        }
     *      ]
     *    }
     *
     * POST /api/orders/{order}/series/create
     *
     * Parametr {order} = dowolne zamówienie z tego samego order_number
     * (zazwyczaj aktualna seria, z której widoku user klika "Nowa seria").
     */
    public function create(Request $request, Order $order): JsonResponse
    {
        // Walidacja danych wejściowych
        $validated = $request->validate([
            'description' => 'nullable|string|max:1000',
            'planned_delivery_date' => 'nullable|date',
            'priority' => 'nullable|string|in:low,normal,high,urgent',

            // Opcjonalne — tylko gdy kopiujemy z innej serii
            'copy_from_order_id' => 'nullable|integer|exists:orders,id',

            // Lista wariantów do skopiowania
            'variants' => 'nullable|array',
            'variants.*.source_variant_id' => [
                'required_with:variants',
                'integer',
                'exists:variants,id',
            ],
            'variants.*.copy_quotation' => 'nullable|boolean',
            'variants.*.copy_materials' => 'nullable|boolean',
        ]);

        try {
            // Jeśli podano copy_from_order_id — sprawdź czy ma ten sam order_number
            $sourceForCopy = null;
            if (!empty($validated['copy_from_order_id'])) {
                $sourceForCopy = Order::findOrFail($validated['copy_from_order_id']);

                if ($sourceForCopy->order_number !== $order->order_number) {
                    return response()->json([
                        'message' => "Seria źródłowa (#{$sourceForCopy->id}, " .
                            "{$sourceForCopy->full_order_number}) ma inny numer zamówienia " .
                            "niż {$order->full_order_number}. " .
                            "Można kopiować tylko z tej samej grupy serii.",
                        'errors' => [
                            'copy_from_order_id' => [
                                'Seria źródłowa musi mieć ten sam numer zamówienia.'
                            ]
                        ]
                    ], 422);
                }

                // Sprawdź czy wszystkie warianty do skopiowania należą do copy_from_order_id
                if (!empty($validated['variants'])) {
                    $sourceVariantIds = Variant::where('order_id', $sourceForCopy->id)
                        ->pluck('id')
                        ->toArray();

                    foreach ($validated['variants'] as $variantConfig) {
                        if (!in_array($variantConfig['source_variant_id'], $sourceVariantIds)) {
                            return response()->json([
                                'message' => "Wariant #{$variantConfig['source_variant_id']} " .
                                    "nie należy do serii #{$sourceForCopy->id} " .
                                    "({$sourceForCopy->full_order_number}).",
                                'errors' => [
                                    'variants' => [
                                        "Wariant #{$variantConfig['source_variant_id']} " .
                                        "nie należy do wybranej serii źródłowej."
                                    ]
                                ]
                            ], 422);
                        }
                    }
                }
            }

            // Dane nowego zamówienia
            $orderData = [
                'description' => $validated['description'],
                'planned_delivery_date' => $validated['planned_delivery_date'] ?? null,
                'priority' => $validated['priority'] ?? 'normal',
            ];

            // Warianty do skopiowania (null = pusta seria)
            $variantsToCopy = !empty($validated['variants']) ? $validated['variants'] : null;

            // Tworzymy nową serię — zawsze na podstawie order_number z $order
            // (niezależnie od tego, którą serię user wskazał jako źródło kopii)
            $newOrder = $this->seriesService->createNewSeries(
                sourceOrder: $order,
                orderData: $orderData,
                variantsToCopy: $variantsToCopy
            );

            // Przygotuj opis tego co zostało zrobione
            $summary = $this->buildCreationSummary($newOrder, $variantsToCopy, $sourceForCopy);

            return response()->json([
                'message' => "Nowa seria {$newOrder->full_order_number} utworzona pomyślnie.",
                'data' => $newOrder,
                'summary' => $summary,
            ], 201);

        } catch (\InvalidArgumentException $e) {
            // Błędy walidacji biznesowej z SeriesService
            return response()->json([
                'message' => $e->getMessage(),
            ], 422);
        } catch (\Exception $e) {
            Log::error("OrderSeriesController::create error: {$e->getMessage()}", [
                'order_id' => $order->id,
                'request' => $request->all(),
                'trace' => $e->getTraceAsString(),
            ]);
            return response()->json([
                'message' => 'Błąd podczas tworzenia nowej serii',
                'error' => $e->getMessage(),
            ], 500);
        }
    }

    // =========================================================================
    // POMOCNICZE
    // =========================================================================

    /**
     * Zbuduj czytelne podsumowanie operacji tworzenia serii.
     * Używane do informowania frontendu co zostało wykonane.
     */
    private function buildCreationSummary(
        Order $newOrder,
        ?array $variantsToCopy,
        ?Order $sourceOrder
    ): array {
        $summary = [
            'new_order_id' => $newOrder->id,
            'new_full_order_number' => $newOrder->full_order_number,
            'variants_created' => $newOrder->variants->count(),
            'copied_from' => $sourceOrder?->full_order_number,
        ];

        if (!empty($variantsToCopy)) {
            $withQuotation = collect($variantsToCopy)->where('copy_quotation', true)->count();
            $withMaterials = collect($variantsToCopy)->where('copy_materials', true)->count();

            $summary['copy_details'] = [
                'variants_requested' => count($variantsToCopy),
                'with_quotation_copy' => $withQuotation,
                'with_materials_copy' => $withMaterials,
            ];
        }

        return $summary;
    }
}


=================================================================================
FILE: app/Http/Controllers/API/PrototypeController.php
LOCATION: .//app/Http/Controllers/API/PrototypeController.php
=================================================================================

<?php

namespace App\Http\Controllers\API;

use App\Http\Controllers\Controller;
use App\Models\Variant;
use App\Models\Prototype;
use App\Models\PrototypeService;
use App\Enums\ProductionStatus;
use Illuminate\Http\Request;
use Illuminate\Http\JsonResponse;
use Illuminate\Support\Facades\DB;

class PrototypeController extends Controller
{
    /**
     * Lista prototypów wariantu z materiałami i usługami RCP
     *
     * GET /api/variants/{variant}/prototypes
     */
    public function index(Variant $variant): JsonResponse
    {
        $prototypes = $variant->prototypes()
            ->with([
                'materials.assortment',
                'services.workstation',
                'services.assignedWorker',
            ])
            ->orderBy('version_number', 'desc')
            ->get();

        return response()->json($prototypes);
    }

    /**
     * Szczegóły prototypu z materiałami i usługami RCP
     *
     * GET /api/prototypes/{prototype}
     */
    public function show(Prototype $prototype): JsonResponse
    {
        $prototype->load([
            'variant.order.customer',
            'materials.assortment',
            'services.workstation',
            'services.assignedWorker',
        ]);

        return response()->json([
            'data' => $prototype,
            'materials_summary' => $prototype->materials_status_summary,
            'total_materials_cost' => $prototype->total_materials_cost,
            'total_services_cost' => $prototype->total_services_cost,
            'total_cost' => $prototype->total_cost,
        ]);
    }

    /**
     * Utwórz nowy prototyp
     *
     * POST /api/variants/{variant}/prototypes
     */
    public function store(Request $request, Variant $variant): JsonResponse
    {
        $validated = $request->validate([
            'feedback_notes' => 'nullable|string',
        ]);

        // Pobierz następny numer wersji
        $nextVersion = $variant->prototypes()->max('version_number') + 1;

        $prototype = $variant->prototypes()->create([
            'version_number' => $nextVersion,
            'test_result' => 'PENDING',
            'feedback_notes' => $validated['feedback_notes'] ?? null,
            'sent_to_client_date' => now(),
        ]);

        $prototype->load(['materials.assortment', 'services']);

        return response()->json($prototype, 201);
    }

    /**
     * Aktualizuj prototyp
     *
     * PUT /api/prototypes/{prototype}
     */
    public function update(Request $request, Prototype $prototype): JsonResponse
    {
        $validated = $request->validate([
            'test_result' => 'sometimes|in:PENDING,PASSED,FAILED',
            'feedback_notes' => 'nullable|string',
            'sent_to_client_date' => 'nullable|date',
            'client_response_date' => 'nullable|date',
        ]);

        $prototype->update($validated);

        return response()->json($prototype);
    }

    /**
     * Zatwierdź prototyp (jeden zatwierdzony na wariant)
     *
     * PATCH /api/prototypes/{prototype}/approve
     */
    public function approve(Prototype $prototype): JsonResponse
    {
        return DB::transaction(function () use ($prototype) {
            // Odznacz wszystkie inne prototypy tego wariantu
            Prototype::where('variant_id', $prototype->variant_id)
                ->update(['is_approved' => false]);

            // Zatwierdź ten prototyp
            $prototype->update([
                'is_approved' => true,
                'test_result' => 'PASSED',
                'client_response_date' => now(),
            ]);

            // Zaktualizuj wariant — ustaw zatwierdzony prototyp
            $prototype->variant->update([
                'approved_prototype_id' => $prototype->id,
            ]);

            $prototype->load(['materials.assortment', 'services']);

            return response()->json($prototype);
        });
    }

    /**
     * Odrzuć prototyp
     *
     * PATCH /api/prototypes/{prototype}/reject
     */
    public function reject(Request $request, Prototype $prototype): JsonResponse
    {
        $validated = $request->validate([
            'feedback_notes' => 'nullable|string',
        ]);

        $prototype->update([
            'test_result' => 'FAILED',
            'client_response_date' => now(),
            'feedback_notes' => $validated['feedback_notes'] ?? $prototype->feedback_notes,
        ]);

        return response()->json($prototype);
    }

    // =========================================================================
    // USŁUGI RCP PROTOTYPU (oddzielne od production_services)
    // =========================================================================

    /**
     * Lista zadań RCP prototypu
     *
     * GET /api/prototypes/{prototype}/services
     */
    public function services(Prototype $prototype): JsonResponse
    {
        $services = $prototype->services()
            ->with(['workstation', 'assignedWorker'])
            ->orderBy('step_number')
            ->get();

        return response()->json($services);
    }

    /**
     * Dodaj zadanie RCP do prototypu
     *
     * POST /api/prototypes/{prototype}/services
     */
    public function storeService(Request $request, Prototype $prototype): JsonResponse
    {
        $validated = $request->validate([
            'service_name' => 'required|string|max:255',
            'workstation_id' => 'nullable|exists:workstations,id',
            'assigned_to_user_id' => 'nullable|exists:users,id',
            'estimated_quantity' => 'sometimes|numeric|min:0',
            'estimated_time_hours' => 'required|numeric|min:0',
            'unit_price' => 'required|numeric|min:0',
            'worker_notes' => 'nullable|string',
        ]);

        // Następny numer kroku
        $nextStep = $prototype->services()->max('step_number') + 1;

        $validated['step_number'] = $nextStep;
        $validated['estimated_quantity'] = $validated['estimated_quantity'] ?? 1;
        $validated['estimated_cost'] = ($validated['estimated_quantity'] ?? 1) * $validated['unit_price'];

        $service = $prototype->services()->create($validated);
        $service->load(['workstation', 'assignedWorker']);

        return response()->json($service, 201);
    }

    /**
     * Aktualizuj zadanie RCP prototypu
     *
     * PUT /api/prototype-services/{service}
     */
    public function updateService(Request $request, PrototypeService $service): JsonResponse
    {
        $validated = $request->validate([
            'service_name' => 'sometimes|string|max:255',
            'workstation_id' => 'nullable|exists:workstations,id',
            'assigned_to_user_id' => 'nullable|exists:users,id',
            'estimated_quantity' => 'sometimes|numeric|min:0',
            'estimated_time_hours' => 'sometimes|numeric|min:0',
            'unit_price' => 'sometimes|numeric|min:0',
            'actual_quantity' => 'nullable|numeric|min:0',
            'actual_time_hours' => 'nullable|numeric|min:0',
            'actual_cost' => 'nullable|numeric|min:0',
            'status' => 'sometimes|in:PLANNED,IN_PROGRESS,PAUSED,COMPLETED,CANCELLED',
            'worker_notes' => 'nullable|string',
        ]);

        // Przelicz szacowany koszt jeśli zmieniono dane
        $quantity = $validated['estimated_quantity'] ?? $service->estimated_quantity;
        $unitPrice = $validated['unit_price'] ?? $service->unit_price;
        $validated['estimated_cost'] = $quantity * $unitPrice;

        $service->update($validated);
        $service->load(['workstation', 'assignedWorker']);

        return response()->json($service);
    }

    /**
     * Usuń zadanie RCP prototypu
     *
     * DELETE /api/prototype-services/{service}
     */
    public function destroyService(PrototypeService $service): JsonResponse
    {
        if ($service->status !== ProductionStatus::PLANNED) {
            return response()->json([
                'message' => 'Można usunąć tylko zaplanowane zadania'
            ], 400);
        }

        $service->delete();

        return response()->json([
            'message' => 'Zadanie RCP prototypu usunięte pomyślnie'
        ]);
    }
}


=================================================================================
FILE: app/Http/Controllers/API/PrototypeMaterialController.php
LOCATION: .//app/Http/Controllers/API/PrototypeMaterialController.php
=================================================================================

<?php

namespace App\Http\Controllers\API;

use App\Http\Controllers\Controller;
use App\Models\Prototype;
use App\Models\PrototypeMaterial;
use App\Enums\MaterialStatus;
use Illuminate\Http\Request;
use Illuminate\Http\JsonResponse;
use Illuminate\Validation\Rule;

class PrototypeMaterialController extends Controller
{
    /**
     * Lista materiałów prototypu
     *
     * GET /api/prototypes/{prototype}/materials
     */
    public function index(Prototype $prototype): JsonResponse
    {
        $materials = $prototype->materials()
            ->with('assortment')
            ->orderBy('created_at')
            ->get();

        return response()->json([
            'data' => $materials,
            'summary' => $prototype->materials_status_summary,
            'total_cost' => $prototype->total_materials_cost,
        ]);
    }

    /**
     * Dodaj materiał do prototypu
     *
     * POST /api/prototypes/{prototype}/materials
     */
    public function store(Request $request, Prototype $prototype): JsonResponse
    {
        $validated = $request->validate([
            'assortment_id' => 'required|exists:assortment,id',
            'quantity' => 'required|numeric|min:0.01',
            'unit' => 'required|string|max:10',
            'unit_price' => 'required|numeric|min:0',
            'status' => ['nullable', Rule::enum(MaterialStatus::class)],
            'expected_delivery_date' => 'nullable|date',
            'ordered_at' => 'nullable|date',
            'quantity_in_stock' => 'nullable|numeric|min:0',
            'quantity_ordered' => 'nullable|numeric|min:0',
            'supplier' => 'nullable|string|max:255',
            'notes' => 'nullable|string',
        ]);

        $validated['total_cost'] = $validated['quantity'] * $validated['unit_price'];
        $validated['status'] = $validated['status'] ?? MaterialStatus::NOT_ORDERED->value;

        $material = $prototype->materials()->create($validated);
        $material->load('assortment');

        return response()->json($material, 201);
    }

    /**
     * Szczegóły materiału prototypu
     *
     * GET /api/prototype-materials/{material}
     */
    public function show(PrototypeMaterial $material): JsonResponse
    {
        $material->load('assortment', 'prototype');
        return response()->json($material);
    }

    /**
     * Aktualizuj materiał prototypu
     *
     * PUT /api/prototype-materials/{material}
     */
    public function update(Request $request, PrototypeMaterial $material): JsonResponse
    {
        $validated = $request->validate([
            'assortment_id' => 'sometimes|exists:assortment,id',
            'quantity' => 'sometimes|numeric|min:0.01',
            'unit' => 'sometimes|string|max:10',
            'unit_price' => 'sometimes|numeric|min:0',
            'status' => ['sometimes', Rule::enum(MaterialStatus::class)],
            'expected_delivery_date' => 'nullable|date',
            'ordered_at' => 'nullable|date',
            'received_at' => 'nullable|date',
            'quantity_in_stock' => 'sometimes|numeric|min:0',
            'quantity_ordered' => 'sometimes|numeric|min:0',
            'supplier' => 'nullable|string|max:255',
            'notes' => 'nullable|string',
        ]);

        $quantity = $validated['quantity'] ?? $material->quantity;
        $unitPrice = $validated['unit_price'] ?? $material->unit_price;
        $validated['total_cost'] = $quantity * $unitPrice;

        $material->update($validated);
        $material->load('assortment');

        return response()->json($material);
    }

    /**
     * Usuń materiał prototypu
     *
     * DELETE /api/prototype-materials/{material}
     */
    public function destroy(PrototypeMaterial $material): JsonResponse
    {
        $material->delete();

        return response()->json([
            'message' => 'Materiał prototypu usunięty pomyślnie'
        ]);
    }

    /**
     * Zmień status materiału prototypu (szybka akcja)
     *
     * PATCH /api/prototype-materials/{material}/status
     */
    public function updateStatus(Request $request, PrototypeMaterial $material): JsonResponse
    {
        $validated = $request->validate([
            'status' => ['required', Rule::enum(MaterialStatus::class)],
            'expected_delivery_date' => 'nullable|date',
            'ordered_at' => 'nullable|date',
            'received_at' => 'nullable|date',
            'quantity_in_stock' => 'nullable|numeric|min:0',
            'quantity_ordered' => 'nullable|numeric|min:0',
        ]);

        $status = MaterialStatus::from($validated['status']);

        if ($status === MaterialStatus::ORDERED && !isset($validated['ordered_at'])) {
            $validated['ordered_at'] = now()->toDateString();
        }

        if ($status === MaterialStatus::IN_STOCK && !isset($validated['received_at'])) {
            $validated['received_at'] = now()->toDateString();
            $validated['quantity_in_stock'] = $material->quantity;
        }

        $material->update($validated);
        $material->load('assortment');

        return response()->json($material);
    }
}


=================================================================================
FILE: app/Http/Controllers/API/QuotationController.php
LOCATION: .//app/Http/Controllers/API/QuotationController.php
=================================================================================

<?php

namespace App\Http\Controllers\API;

use Barryvdh\DomPDF\Facade\Pdf;
use App\Http\Controllers\Controller;
use App\Models\Variant;
use App\Models\Quotation;
use App\Models\QuotationItem;
use App\Models\QuotationItemMaterial;
use App\Models\QuotationItemService;
use App\Models\VariantMaterial;
use App\Enums\MaterialStatus;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;

class QuotationController extends Controller
{
    /**
     * Lista wycen dla wariantu
     *
     * GET /api/variants/{variant}/quotations
     */
    public function index(Variant $variant)
    {
        try {
            $quotations = $variant->quotations()
                ->with([
                    'items.materials.assortmentItem',
                    'items.services.assortmentItem',
                    'approvedBy'
                ])
                ->orderBy('version_number', 'desc')
                ->get();

            return response()->json($quotations);
        } catch (\Exception $e) {
            Log::error('Quotations index error: ' . $e->getMessage());
            return response()->json([
                'message' => 'Błąd podczas pobierania wycen',
                'error' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Szczegóły wyceny
     *
     * GET /api/quotations/{quotation}
     */
    public function show(Quotation $quotation)
    {
        try {
            $quotation->load([
                'variant.order.customer',
                'items.materials.assortmentItem',
                'items.services.assortmentItem',
                'approvedBy'
            ]);

            return response()->json($quotation);
        } catch (\Exception $e) {
            Log::error('Quotation show error: ' . $e->getMessage());
            return response()->json([
                'message' => 'Błąd podczas pobierania wyceny',
                'error' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Utwórz nową wycenę dla wariantu
     *
     * POST /api/variants/{variant}/quotations
     */
    public function store(Request $request, Variant $variant)
    {
        try {
            $validated = $request->validate([
                // present zamiast required — klucz musi istnieć, ale tablica może być pusta
                'materials' => 'present|array',
                'materials.*.assortment_item_id' => 'required|exists:assortment,id',
                'materials.*.quantity' => 'required|numeric|min:0.01',
                'materials.*.unit' => 'required|string|max:10',
                'materials.*.unit_price' => 'required|numeric|min:0',
                'materials.*.notes' => 'nullable|string',
                'services' => 'present|array',
                'services.*.assortment_item_id' => 'required|exists:assortment,id',
                'services.*.estimated_time_hours' => 'required|numeric|min:0',
                'services.*.unit_price' => 'required|numeric|min:0',
                'services.*.notes' => 'nullable|string',
                'margin_percent' => 'required|numeric|min:0|max:100',
                'notes' => 'nullable|string',
            ]);

            return DB::transaction(function () use ($variant, $validated) {
                $materialsCost = collect($validated['materials'])
                    ->sum(fn($m) => $m['quantity'] * $m['unit_price']);

                $servicesCost = collect($validated['services'])
                    ->sum(fn($s) => $s['estimated_time_hours'] * $s['unit_price']);

                $subtotal = $materialsCost + $servicesCost;
                $totalNet = $subtotal * (1 + $validated['margin_percent'] / 100);
                $totalGross = $totalNet * 1.23;

                $nextVersion = Quotation::where('variant_id', $variant->id)
                    ->max('version_number') + 1;

                $quotation = $variant->quotations()->create([
                    'version_number' => $nextVersion,
                    'total_materials_cost' => $materialsCost,
                    'total_services_cost' => $servicesCost,
                    'total_net' => $totalNet,
                    'total_gross' => $totalGross,
                    'margin_percent' => $validated['margin_percent'],
                    'notes' => $validated['notes'] ?? null,
                ]);

                $quotationItem = $quotation->items()->create([
                    'materials_cost' => $materialsCost,
                    'services_cost' => $servicesCost,
                    'subtotal' => $subtotal,
                ]);

                foreach ($validated['materials'] as $material) {
                    $quotationItem->materials()->create([
                        'assortment_item_id' => $material['assortment_item_id'],
                        'quantity' => $material['quantity'],
                        'unit' => $material['unit'] ?? 'szt',
                        'unit_price' => $material['unit_price'],
                        'total_cost' => $material['quantity'] * $material['unit_price'],
                        'notes' => $material['notes'] ?? null,
                    ]);
                }

                foreach ($validated['services'] as $service) {
                    $quotationItem->services()->create([
                        'assortment_item_id' => $service['assortment_item_id'],
                        'estimated_quantity' => 1,
                        'estimated_time_hours' => $service['estimated_time_hours'],
                        'unit' => 'h',
                        'unit_price' => $service['unit_price'],
                        'total_cost' => $service['estimated_time_hours'] * $service['unit_price'],
                        'notes' => $service['notes'] ?? null,
                    ]);
                }

                $quotation->load([
                    'items.materials.assortmentItem',
                    'items.services.assortmentItem'
                ]);

                return response()->json($quotation, 201);
            });

        } catch (\Illuminate\Validation\ValidationException $e) {
            return response()->json([
                'message' => 'Błąd walidacji',
                'errors' => $e->errors()
            ], 422);
        } catch (\Exception $e) {
            Log::error('Quotation store error: ' . $e->getMessage());
            return response()->json([
                'message' => 'Błąd podczas tworzenia wyceny',
                'error' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Aktualizuj wycenę (tylko niezatwierdzone)
     *
     * PUT /api/quotations/{quotation}
     */
    public function update(Request $request, Quotation $quotation)
    {
        try {
            if ($quotation->is_approved) {
                return response()->json([
                    'message' => 'Nie można edytować zatwierdzonej wyceny'
                ], 422);
            }

            $validated = $request->validate([
                // present zamiast required — klucz musi istnieć, ale tablica może być pusta
                'materials' => 'present|array',
                'materials.*.assortment_item_id' => 'required|exists:assortment,id',
                'materials.*.quantity' => 'required|numeric|min:0.01',
                'materials.*.unit' => 'required|string|max:10',
                'materials.*.unit_price' => 'required|numeric|min:0',
                'materials.*.notes' => 'nullable|string',
                'services' => 'present|array',
                'services.*.assortment_item_id' => 'required|exists:assortment,id',
                'services.*.estimated_time_hours' => 'required|numeric|min:0',
                'services.*.unit_price' => 'required|numeric|min:0',
                'services.*.notes' => 'nullable|string',
                'margin_percent' => 'required|numeric|min:0|max:100',
                'notes' => 'nullable|string',
            ]);

            return DB::transaction(function () use ($quotation, $validated) {
                $materialsCost = collect($validated['materials'])
                    ->sum(fn($m) => $m['quantity'] * $m['unit_price']);

                $servicesCost = collect($validated['services'])
                    ->sum(fn($s) => $s['estimated_time_hours'] * $s['unit_price']);

                $subtotal = $materialsCost + $servicesCost;
                $totalNet = $subtotal * (1 + $validated['margin_percent'] / 100);
                $totalGross = $totalNet * 1.23;

                $quotation->update([
                    'total_materials_cost' => $materialsCost,
                    'total_services_cost' => $servicesCost,
                    'total_net' => $totalNet,
                    'total_gross' => $totalGross,
                    'margin_percent' => $validated['margin_percent'],
                    'notes' => $validated['notes'] ?? null,
                ]);

                $quotation->items()->each(function ($item) {
                    $item->materials()->delete();
                    $item->services()->delete();
                    $item->delete();
                });

                $quotationItem = $quotation->items()->create([
                    'materials_cost' => $materialsCost,
                    'services_cost' => $servicesCost,
                    'subtotal' => $subtotal,
                ]);

                foreach ($validated['materials'] as $material) {
                    $quotationItem->materials()->create([
                        'assortment_item_id' => $material['assortment_item_id'],
                        'quantity' => $material['quantity'],
                        'unit' => strtoupper($material['unit'] ?? 'SZT'),
                        'unit_price' => $material['unit_price'],
                        'total_cost' => $material['quantity'] * $material['unit_price'],
                        'notes' => $material['notes'] ?? null,
                    ]);
                }

                foreach ($validated['services'] as $service) {
                    $quotationItem->services()->create([
                        'assortment_item_id' => $service['assortment_item_id'],
                        'estimated_quantity' => 1,
                        'estimated_time_hours' => $service['estimated_time_hours'],
                        'unit' => 'H',
                        'unit_price' => $service['unit_price'],
                        'total_cost' => $service['estimated_time_hours'] * $service['unit_price'],
                        'notes' => $service['notes'] ?? null,
                    ]);
                }

                return response()->json($quotation->load([
                    'items.materials.assortmentItem',
                    'items.services.assortmentItem'
                ]));
            });

        } catch (\Exception $e) {
            Log::error('Quotation update error: ' . $e->getMessage());
            return response()->json([
                'message' => 'Błąd podczas aktualizacji wyceny',
                'error' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Zatwierdź wycenę
     *
     * PATCH /api/quotations/{quotation}/approve
     */
    public function approve(Quotation $quotation)
    {
        try {
            return DB::transaction(function () use ($quotation) {
                Quotation::where('variant_id', $quotation->variant_id)
                    ->update(['is_approved' => false]);

                $quotation->update([
                    'is_approved' => true,
                    'approved_at' => now(),
                    'approved_by_user_id' => auth()->id(),
                ]);

                return response()->json([
                    'message' => 'Wycena zatwierdzona',
                    'quotation' => $quotation
                ]);
            });
        } catch (\Exception $e) {
            Log::error('Quotation approve error: ' . $e->getMessage());
            return response()->json([
                'message' => 'Błąd podczas zatwierdzania wyceny',
                'error' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Usuń wycenę
     *
     * DELETE /api/quotations/{quotation}
     */
    public function destroy(Quotation $quotation)
    {
        try {
            if ($quotation->is_approved) {
                return response()->json([
                    'message' => 'Nie można usunąć zatwierdzonej wyceny'
                ], 400);
            }

            $quotation->delete();

            return response()->json(['message' => 'Wycena usunięta pomyślnie']);
        } catch (\Exception $e) {
            Log::error('Quotation delete error: ' . $e->getMessage());
            return response()->json([
                'message' => 'Błąd podczas usuwania wyceny',
                'error' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Generuj i pobierz PDF wyceny
     *
     * GET /api/quotations/{quotation}/pdf
     */
    public function downloadPdf(Quotation $quotation)
    {
        try {
            $quotation->load([
                'variant.order.customer',
                'items.materials.assortmentItem',
                'items.services.assortmentItem',
                'approvedBy'
            ]);

            $filename = 'Wycena_' . $quotation->variant->order->full_order_number
                . '_v' . $quotation->version_number . '.pdf';

            $filename = str_replace('/', '-', $filename);

            $pdf = Pdf::loadView('quotation', [
                'quotation' => $quotation,
                'order' => $quotation->variant->order,
                'customer' => $quotation->variant->order->customer,
                'variant' => $quotation->variant
            ]);

            return $pdf->download($filename);

        } catch (\Exception $e) {
            Log::error('PDF generation error: ' . $e->getMessage());
            return response()->json([
                'message' => 'Błąd podczas generowania PDF',
                'error' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Duplikuj wycenę jako nową wersję w tym samym wariancie
     *
     * POST /api/quotations/{quotation}/duplicate
     */
    public function duplicate(Quotation $quotation)
    {
        try {
            return DB::transaction(function () use ($quotation) {
                $quotation->load(['items.materials', 'items.services']);

                $nextVersion = Quotation::where('variant_id', $quotation->variant_id)
                    ->max('version_number') + 1;

                $newQuotation = Quotation::create([
                    'variant_id' => $quotation->variant_id,
                    'version_number' => $nextVersion,
                    'total_materials_cost' => $quotation->total_materials_cost,
                    'total_services_cost' => $quotation->total_services_cost,
                    'total_net' => $quotation->total_net,
                    'total_gross' => $quotation->total_gross,
                    'margin_percent' => $quotation->margin_percent,
                    'is_approved' => false,
                    'approved_at' => null,
                    'approved_by_user_id' => null,
                    'notes' => $quotation->notes
                        ? '[Kopia v' . $quotation->version_number . '] ' . $quotation->notes
                        : '[Kopia v' . $quotation->version_number . ']',
                ]);

                foreach ($quotation->items as $item) {
                    $newItem = QuotationItem::create([
                        'quotation_id' => $newQuotation->id,
                        'materials_cost' => $item->materials_cost,
                        'services_cost' => $item->services_cost,
                        'subtotal' => $item->subtotal,
                    ]);

                    foreach ($item->materials as $material) {
                        QuotationItemMaterial::create([
                            'quotation_item_id' => $newItem->id,
                            'assortment_item_id' => $material->assortment_item_id,
                            'quantity' => $material->quantity,
                            'unit' => $material->unit,
                            'unit_price' => $material->unit_price,
                            'total_cost' => $material->total_cost,
                            'notes' => $material->notes,
                        ]);
                    }

                    foreach ($item->services as $service) {
                        QuotationItemService::create([
                            'quotation_item_id' => $newItem->id,
                            'assortment_item_id' => $service->assortment_item_id,
                            'estimated_quantity' => $service->estimated_quantity,
                            'estimated_time_hours' => $service->estimated_time_hours,
                            'unit' => $service->unit,
                            'unit_price' => $service->unit_price,
                            'total_cost' => $service->total_cost,
                            'notes' => $service->notes,
                        ]);
                    }
                }

                $newQuotation->load([
                    'items.materials.assortmentItem',
                    'items.services.assortmentItem',
                ]);

                Log::info("Wycena #{$quotation->id} (v{$quotation->version_number}) " .
                    "zduplikowana jako #{$newQuotation->id} (v{$nextVersion})");

                return response()->json([
                    'message' => "Wycena zduplikowana jako wersja {$nextVersion}",
                    'quotation' => $newQuotation,
                ], 201);
            });

        } catch (\Exception $e) {
            Log::error('Quotation duplicate error: ' . $e->getMessage());
            return response()->json([
                'message' => 'Błąd podczas duplikowania wyceny',
                'error' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Eksportuj materiały z zatwierdzonej wyceny do listy materiałów wariantu.
     *
     * Dostępne tryby (query param ?mode=):
     *  - skip    (domyślny) – pomija istniejące
     *  - merge   – sumuje ilości z istniejącymi
     *  - replace – nadpisuje istniejące (usuwa też duplikaty assortment_id)
     *
     * POST /api/quotations/{quotation}/export-materials?mode=skip|merge|replace
     */
    public function exportMaterials(Request $request, Quotation $quotation)
    {
        if (!$quotation->is_approved) {
            return response()->json([
                'message' => 'Można eksportować materiały tylko z zatwierdzonej wyceny',
            ], 422);
        }

        $mode = $request->query('mode', 'skip');

        if (!in_array($mode, ['skip', 'merge', 'replace'])) {
            return response()->json([
                'message' => 'Nieprawidłowy tryb. Dozwolone: skip, merge, replace',
            ], 422);
        }

        try {
            return DB::transaction(function () use ($quotation, $mode) {
                $quotation->load('items.materials');

                // Spłaszcz materiały z wyceny do jednej kolekcji
                $sourceMaterials = $quotation->items
                    ->flatMap(fn($item) => $item->materials);

                if ($sourceMaterials->isEmpty()) {
                    return response()->json([
                        'message' => 'Wycena nie zawiera żadnych materiałów',
                    ], 422);
                }

                $variant = $quotation->variant;
                $stats = ['exported' => 0, 'skipped' => 0, 'merged' => 0, 'replaced' => 0];

                // ----------------------------------------------------------------
                // REPLACE — semantyka "zastąp całą listę":
                //   1. Usuń WSZYSTKIE materiały wariantu
                //   2. Wstaw materiały z wyceny jako nowe rekordy
                //
                // Nie ma sensu porównywać per-pozycję bo i tak czyścimy wszystko.
                // Dzięki temu wynik jest zawsze równy dokładnie temu co jest w wycenie.
                // ----------------------------------------------------------------
                if ($mode === 'replace') {
                    $deletedCount = $variant->materials()->delete();

                    foreach ($sourceMaterials as $source) {
                        VariantMaterial::create([
                            'variant_id' => $variant->id,
                            'assortment_id' => $source->assortment_item_id,
                            'quantity' => $source->quantity,
                            'unit' => $source->unit,
                            'unit_price' => $source->unit_price,
                            'total_cost' => $source->total_cost,
                            'notes' => $source->notes,
                            'status' => MaterialStatus::NOT_ORDERED,
                        ]);
                        $stats['replaced']++;
                    }

                    Log::info("Eksport materiałów z wyceny #{$quotation->id} " .
                        "do wariantu #{$variant->id}: tryb=replace, " .
                        "usunięto={$deletedCount}, wstawiono={$stats['replaced']}");

                    return response()->json([
                        'message' => $this->buildExportMessage($stats, $mode),
                        'stats' => $stats,
                    ]);
                }

                // ----------------------------------------------------------------
                // SKIP i MERGE — operują na istniejących pozycjach per assortment_id
                //
                // WAŻNE: groupBy zamiast keyBy — wariant może mieć wiele rekordów
                // z tym samym assortment_id (duplikaty). keyBy zachowałby tylko
                // ostatni, przez co wcześniejsze duplikaty nie byłyby usuwane.
                // ----------------------------------------------------------------
                $existingGroups = $variant->materials()
                    ->get()
                    ->groupBy('assortment_id');

                foreach ($sourceMaterials as $source) {
                    $assortmentId = $source->assortment_item_id;
                    $existingGroup = $existingGroups->get($assortmentId); // Collection|null

                    if ($existingGroup && $existingGroup->count() > 0) {
                        match ($mode) {

                            // POMIŃ: pozostaw istniejące bez zmian
                            'skip' => $stats['skipped']++,

                            // SCAL: zsumuj ilości ze wszystkich rekordów (łącznie z duplikatami),
                            //       zaktualizuj pierwszy, usuń duplikaty
                            'merge' => (function () use ($existingGroup, $source, &$stats) {
                                    $first = $existingGroup->first();
                                    $totalQty = (float) $existingGroup->sum('quantity')
                                    + (float) $source->quantity;

                                    $first->update([
                                    'quantity' => $totalQty,
                                    'total_cost' => $totalQty * (float) $first->unit_price,
                                    ]);

                                    foreach ($existingGroup->slice(1) as $dup) {
                                        $dup->delete();
                                    }

                                    $stats['merged']++;
                                })(),

                            // (replace obsługiwany osobno powyżej — ta gałąź nie powinna wystąpić)
                            default => null,
                        };
                    } else {
                        // Nowy materiał — utwórz w wariancie
                        VariantMaterial::create([
                            'variant_id' => $variant->id,
                            'assortment_id' => $assortmentId,
                            'quantity' => $source->quantity,
                            'unit' => $source->unit,
                            'unit_price' => $source->unit_price,
                            'total_cost' => $source->total_cost,
                            'notes' => $source->notes,
                            'status' => MaterialStatus::NOT_ORDERED,
                        ]);
                        $stats['exported']++;
                    }
                }

                Log::info("Eksport materiałów z wyceny #{$quotation->id} " .
                    "do wariantu #{$variant->id}: tryb={$mode}, " . json_encode($stats));

                return response()->json([
                    'message' => $this->buildExportMessage($stats, $mode),
                    'stats' => $stats,
                ]);
            });

        } catch (\Exception $e) {
            Log::error('Eksport materiałów z wyceny error: ' . $e->getMessage());
            return response()->json([
                'message' => 'Błąd podczas eksportu materiałów',
                'error' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Zbuduj czytelny komunikat podsumowujący eksport
     */
    private function buildExportMessage(array $stats, string $mode): string
    {
        $parts = [];

        if ($stats['exported'] > 0) {
            $parts[] = "dodano {$stats['exported']} nowych";
        }
        if ($stats['merged'] > 0) {
            $parts[] = "scalono ilości w {$stats['merged']}";
        }
        if ($stats['replaced'] > 0) {
            $parts[] = "zastąpiono {$stats['replaced']}";
        }
        if ($stats['skipped'] > 0) {
            $parts[] = "pominięto {$stats['skipped']} istniejących";
        }

        if (empty($parts)) {
            return 'Brak materiałów do eksportu.';
        }

        return 'Eksport zakończony: ' . implode(', ', $parts) . '.';
    }
}


=================================================================================
FILE: app/Http/Controllers/API/RCPController.php
LOCATION: .//app/Http/Controllers/API/RCPController.php
=================================================================================

<?php

namespace App\Http\Controllers\API;

use App\Http\Controllers\Controller;
use App\Services\RcpService;
use App\Models\ProductionService;
use App\Models\ServiceTimeLog;
use App\Models\Variant;
use App\Enums\ProductionStatus;
use App\Enums\EventType;
use Illuminate\Http\Request;
use Illuminate\Http\JsonResponse;
use Carbon\Carbon;

class RcpController extends Controller
{
    public function __construct(protected RcpService $rcpService)
    {
    }

    // =========================================================================
    // PANEL PRACOWNIKA — pomocnicze endpointy
    // =========================================================================

    /**
     * Sprawdź czy zalogowany użytkownik ma aktywne lub wstrzymane zadanie.
     *
     * GET /api/rcp/active-task
     */
    public function checkActiveTask(Request $request): JsonResponse
    {
        $task = ProductionService::where('assigned_to_user_id', $request->user()->id)
            ->whereIn('status', [ProductionStatus::IN_PROGRESS, ProductionStatus::PAUSED])
            ->latest('updated_at')
            ->first();

        if ($task) {
            return response()->json([
                'has_active_task' => true,
                'task_id' => $task->id,
            ]);
        }

        return response()->json(['has_active_task' => false]);
    }

    /**
     * Szczegóły zadania z obliczonym bieżącym czasem (do widoku timera).
     *
     * GET /api/rcp/tasks/{task}
     */
    public function getTaskDetails(ProductionService $task): JsonResponse
    {
        $task->load(['workstation', 'assignedWorker', 'productionOrder.variant.order.customer']);

        $elapsedSeconds = 0;

        $startLog = ServiceTimeLog::where('production_service_id', $task->id)
            ->where('event_type', EventType::START)
            ->latest('event_timestamp')
            ->first();

        if ($startLog) {
            $totalDuration = Carbon::parse($startLog->event_timestamp)->diffInSeconds(now());

            // Suma zakończonych pauz (z zapisanym elapsed_seconds)
            $totalPause = ServiceTimeLog::where('production_service_id', $task->id)
                ->where('event_type', EventType::PAUSE)
                ->whereNotNull('elapsed_seconds')
                ->sum('elapsed_seconds');

            // Jeśli zadanie jest teraz w pauzie — dolicz trwającą pauzę
            if ($task->status === ProductionStatus::PAUSED) {
                $openPauseLog = ServiceTimeLog::where('production_service_id', $task->id)
                    ->where('event_type', EventType::PAUSE)
                    ->whereNull('elapsed_seconds')
                    ->latest('event_timestamp')
                    ->first();

                if ($openPauseLog) {
                    $totalPause += Carbon::parse($openPauseLog->event_timestamp)->diffInSeconds(now());
                }
            }

            $elapsedSeconds = max(0, $totalDuration - $totalPause);
        }

        $taskData = $task->toArray();
        $taskData['current_duration_seconds'] = $elapsedSeconds;

        return response()->json($taskData);
    }

    /**
     * Lista wariantów dostępnych do produkcji (status PRODUCTION, z aktywnym zleceniem).
     *
     * GET /api/rcp/variants
     */
    public function getAvailableVariants(): JsonResponse
    {
        $variants = Variant::with(['order.customer'])
            ->where('status', 'PRODUCTION')
            // ->whereHas('productionOrder')
            ->get()
            ->map(fn($variant) => [
                'id' => $variant->id,
                'order_id' => $variant->order_id,
                'order_number' => $variant->order->order_number,
                'series' => $variant->order->series,
                'full_order_number' => $variant->order->full_order_number,
                'variant_number' => $variant->variant_number,
                'name' => $variant->name,
                'quantity' => $variant->quantity,
                'customer_name' => $variant->order->customer->name ?? 'Brak klienta',
                'priority' => $variant->order->priority ?? 'NORMAL',
                'status' => $variant->status,
            ]);

        return response()->json($variants);
    }

    // =========================================================================
    // TIMER — główne operacje
    // =========================================================================

    /**
     * Rozpocznij pracę (tworzy lub wznawia zadanie przez firstOrCreate).
     *
     * POST /api/rcp/start
     * Body: { variant_id, workstation_id, service_id }
     */
    public function start(Request $request): JsonResponse
    {
        $validated = $request->validate([
            'variant_id' => 'required|integer|exists:variants,id',
            'workstation_id' => 'required|integer|exists:workstations,id',
            'service_id' => 'required|integer|exists:assortment,id',
        ]);

        try {
            $result = $this->rcpService->startWork(
                $validated['variant_id'],
                $validated['workstation_id'],
                $validated['service_id'],
                $request->user()->id
            );

            return response()->json($result);
        } catch (\Exception $e) {
            return response()->json([
                'message' => $e->getMessage(),
            ], 422);
        }
    }

    /**
     * Wstrzymaj pracę (pauza).
     *
     * POST /api/rcp/pause/{task}
     */
    public function pause(ProductionService $task): JsonResponse
    {
        try {
            $result = $this->rcpService->pauseWork($task->id);
            return response()->json($result);
        } catch (\Exception $e) {
            return response()->json(['message' => $e->getMessage()], 422);
        }
    }

    /**
     * Wznów pracę po przerwie.
     *
     * POST /api/rcp/resume/{task}
     */
    public function resume(ProductionService $task): JsonResponse
    {
        try {
            $result = $this->rcpService->resumeWork($task->id);
            return response()->json($result);
        } catch (\Exception $e) {
            return response()->json(['message' => $e->getMessage()], 422);
        }
    }

    /**
     * Zakończ pracę i oblicz wariancję.
     *
     * POST /api/rcp/stop/{task}
     */
    public function stop(ProductionService $task): JsonResponse
    {
        try {
            $result = $this->rcpService->stopWork($task->id);
            return response()->json($result);
        } catch (\Exception $e) {
            return response()->json(['message' => $e->getMessage()], 422);
        }
    }
}


=================================================================================
FILE: app/Http/Controllers/API/RcpAdminController.php
LOCATION: .//app/Http/Controllers/API/RcpAdminController.php
=================================================================================

<?php

namespace App\Http\Controllers\API;

use App\Http\Controllers\Controller;
use App\Models\ProductionService;
use App\Models\ServiceTimeLog;
use App\Enums\EventType;
use App\Enums\ProductionStatus;
use App\Enums\WorkstationStatus;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;
use Illuminate\Validation\Rule;
use Carbon\Carbon;

class RcpAdminController extends Controller
{
    /**
     * Lista zadań produkcyjnych (z filtrowaniem)
     */
    public function index(Request $request)
    {
        $query = ProductionService::with([
            'workstation',
            'assignedWorker',
            'productionOrder.variant.order.customer'
        ]);

        // Filtrowanie Status
        if ($request->has('status') && $request->status !== 'all') {
            $query->where('status', $request->status);
        }

        // Filtrowanie Pracownik
        if ($request->has('worker_id')) {
            $query->where('assigned_to_user_id', $request->worker_id);
        }

        // Filtrowanie Stanowisko
        if ($request->has('workstation_id')) {
            $query->where('workstation_id', $request->workstation_id);
        }

        // Filtrowanie Zakres Dat (Poprawiona logika przecięcia przedziałów)
// Szukamy zadań, które "trwały" w zadanym okresie [date_from, date_to]

        $dateFrom = $request->input('date_from');
        $dateTo = $request->input('date_to');

        if ($dateFrom && $dateTo) {
            $query->where(function ($q) use ($dateFrom, $dateTo) {
                // Zadanie zaczęło się przed końcem filtra ORAZ (skończyło się po początku filtra LUB wciąż trwa)
                $q->where('actual_start_date', '<=', $dateTo)
                    ->where(function ($subQ) use ($dateFrom) {
                        $subQ->where('actual_end_date', '>=', $dateFrom)
                            ->orWhereNull('actual_end_date');
                    });
            });
        } elseif ($dateFrom) {
            // Tylko Data OD: Zadanie skończyło się po tej dacie lub wciąż trwa
            $query->where(function ($q) use ($dateFrom) {
                $q->where('actual_end_date', '>=', $dateFrom)
                    ->orWhereNull('actual_end_date');
            });
        } elseif ($dateTo) {
            // Tylko Data DO: Zadanie zaczęło się przed tą datą
            $query->where('actual_start_date', '<=', $dateTo);
        }

        // Wyszukiwanie Tekstowe
        if ($request->has('search')) {
            $search = $request->search;
            $query->where(function ($q) use ($search) {
                $q->where('service_name', 'like', "%{$search}%")
                    ->orWhereHas('productionOrder.variant', function ($lq) use ($search) {
                        $lq->where('name', 'like', "%{$search}%")
                            ->orWhere('variant_number', 'like', "%{$search}%")
                            ->orWhereHas('order', function ($oq) use ($search) {
                                $oq->where('order_number', 'like', "%{$search}%")
                                    ->orWhereHas('customer', function ($cq) use ($search) {
                                        $cq->where('name', 'like', "%{$search}%");
                                    });
                            });
                    });
            });
        }

        // Sortowanie
        $query->orderBy('updated_at', 'desc');

        return response()->json($query->paginate(20));
    }

    public function update(Request $request, ProductionService $task)
    {
        $validated = $request->validate([
            'status' => ['required', Rule::enum(ProductionStatus::class)],
            'assigned_to_user_id' => 'nullable|exists:users,id',
            'actual_time_hours' => 'nullable|numeric|min:0',
            'actual_quantity' => 'nullable|numeric|min:0',
            'worker_notes' => 'nullable|string',
            'actual_start_date' => 'nullable|date',
            'actual_end_date' => 'nullable|date',
        ]);

        $wasCancelled = $task->status !== ProductionStatus::CANCELLED && $validated['status'] === ProductionStatus::CANCELLED->value;

        $task->fill($validated);

        if ($request->filled('actual_start_date') && $request->filled('actual_end_date') && !$request->filled('actual_time_hours')) {
            $start = Carbon::parse($validated['actual_start_date']);
            $end = Carbon::parse($validated['actual_end_date']);
            $diffHours = abs($start->diffInMinutes($end) / 60);
            $task->actual_time_hours = round($diffHours, 2);
        }

        $task->save();

        if ($wasCancelled) {
            $this->logCancellation($task);
        }

        if ($task->wasChanged('actual_time_hours') || $task->wasChanged('actual_quantity')) {
            $this->recalculateCosts($task);
        }

        return response()->json($task->load(['workstation', 'assignedWorker']));
    }

    public function getLogs(ProductionService $task)
    {
        $logs = $task->timeLogs()->with('user')->orderBy('event_timestamp', 'asc')->get();
        return response()->json($logs);
    }

    public function storeLog(Request $request, ProductionService $task)
    {
        $validated = $request->validate([
            'event_type' => ['required', Rule::enum(EventType::class)],
            'event_timestamp' => 'required|date',
            'user_id' => 'required|exists:users,id',
            'elapsed_seconds' => 'nullable|integer|min:0',
        ]);

        $log = $task->timeLogs()->create([
            'event_type' => $validated['event_type'],
            'event_timestamp' => $validated['event_timestamp'],
            'user_id' => $validated['user_id'],
            'elapsed_seconds' => $validated['elapsed_seconds'] ?? 0,
        ]);

        return response()->json($log);
    }

    public function updateLog(Request $request, ServiceTimeLog $log)
    {
        $validated = $request->validate([
            'event_timestamp' => 'required|date',
            'event_type' => ['required', Rule::enum(EventType::class)],
            'elapsed_seconds' => 'nullable|integer|min:0',
        ]);

        $log->update($validated);
        return response()->json($log);
    }

    public function destroyLog(ServiceTimeLog $log)
    {
        $log->delete();
        return response()->json(['message' => 'Log usunięty']);
    }

    protected function recalculateCosts(ProductionService $task)
    {
        $cost = 0;
        if ($task->estimated_time_hours > 0) {
            $cost = $task->actual_time_hours * $task->unit_price;
        } else {
            $cost = $task->actual_quantity * $task->unit_price;
        }

        $task->update(['actual_cost' => $cost]);

        $order = $task->productionOrder;
        if ($order) {
            $totalActual = $order->services()->sum('actual_cost');
            $order->update(['total_actual_cost' => $totalActual]);
        }
    }

    protected function logCancellation(ProductionService $task)
    {
        $lastLog = $task->timeLogs()->latest('event_timestamp')->first();

        if ($lastLog && in_array($lastLog->event_type, [EventType::START, EventType::RESUME])) {
            $now = Carbon::now();
            $elapsed = 0;

            $task->timeLogs()->create([
                'event_type' => EventType::STOP,
                'event_timestamp' => $now,
                'user_id' => auth()->id() ?? $task->assigned_to_user_id,
                'elapsed_seconds' => $elapsed,
            ]);

            if ($task->workstation && $task->workstation->current_task_id === $task->id) {
                $task->workstation->update([
                    'status' => WorkstationStatus::IDLE,
                    'current_task_id' => null
                ]);
            }
        }
    }
}


=================================================================================
FILE: app/Http/Controllers/API/UserController.php
LOCATION: .//app/Http/Controllers/API/UserController.php
=================================================================================

<?php

namespace App\Http\Controllers\API;

use App\Http\Controllers\Controller;
use App\Models\User;
use App\Enums\UserRole;
use App\Traits\Paginatable;
use App\Http\Resources\UserResource;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use Illuminate\Validation\Rule;
use Illuminate\Support\Facades\DB;
use Illuminate\Validation\ValidationException; // IMPORT WYJĄTKU

class UserController extends Controller
{
    use Paginatable;

    /**
     * Lista użytkowników z paginacją server-side.
     */
    public function index(Request $request)
    {
        $query = User::query();

        // Wyszukiwanie
        if ($request->filled('search')) {
            $search = $request->input('search');
            $query->where(function ($q) use ($search) {
                $q->where('name', 'like', "%{$search}%")
                    ->orWhere('email', 'like', "%{$search}%");
            });
        }

        // Filtracja po roli
        if ($request->filled('role') && $request->role !== 'all') {
            $query->where('role', $request->role);
        }

        // Filtracja po statusie
        if ($request->has('is_active')) {
            $isActive = filter_var($request->input('is_active'), FILTER_VALIDATE_BOOLEAN);
            $query->where('is_active', $isActive);
        }

        // Sortowanie z whitelistą
        $this->applySorting($query, $request, [
            'name',
            'email',
            'role',
            'created_at',
        ], 'name', 'asc');

        // Paginacja
        $users = $this->paginateQuery($query, $request);

        return UserResource::collection($users);
    }

    /**
     * Tworzenie użytkownika
     */
    public function store(Request $request)
    {
        $validated = $request->validate([
            'name' => 'required|string|max:255',
            'email' => 'required|string|email|max:255|unique:users',
            'password' => 'required|string|min:8',
            'role' => ['required', Rule::enum(UserRole::class)],
            'pin_code' => 'nullable|string|size:4',
            'is_active' => 'boolean',
        ]);

        // WALIDACJA UNIKALNOŚCI PIN (HASH)
        if (!empty($validated['pin_code'])) {
            $this->ensurePinIsUnique($validated['pin_code']);
        }

        $user = User::create([
            'name' => $validated['name'],
            'email' => $validated['email'],
            'password' => Hash::make($validated['password']),
            'role' => $validated['role'],
            'pin_code' => isset($validated['pin_code']) ? Hash::make($validated['pin_code']) : null,
            'is_active' => $validated['is_active'] ?? true,
        ]);

        return new UserResource($user);
    }

    /**
     * Szczegóły użytkownika
     */
    public function show(User $user)
    {
        return new UserResource($user);
    }

    /**
     * Aktualizacja użytkownika
     */
    public function update(Request $request, User $user)
    {
        $validated = $request->validate([
            'name' => 'sometimes|required|string|max:255',
            'email' => ['sometimes', 'required', 'email', Rule::unique('users')->ignore($user->id)],
            'password' => 'nullable|string|min:8',
            'role' => ['sometimes', 'required', Rule::enum(UserRole::class)],
            'pin_code' => 'nullable|string|size:4',
            'is_active' => 'boolean',
        ]);

        $data = [
            'name' => $validated['name'] ?? $user->name,
            'email' => $validated['email'] ?? $user->email,
            'role' => $validated['role'] ?? $user->role,
            'is_active' => $validated['is_active'] ?? $user->is_active,
        ];

        // Aktualizuj hasło tylko jeśli podano
        if (!empty($validated['password'])) {
            $data['password'] = Hash::make($validated['password']);
        }

        // Aktualizuj PIN tylko jeśli podano (i nie jest pusty)
        if (array_key_exists('pin_code', $validated)) {
            $newPin = $validated['pin_code'];

            if ($newPin) {
                // WALIDACJA UNIKALNOŚCI PIN (HASH) - z wykluczeniem obecnego użytkownika
                $this->ensurePinIsUnique($newPin, $user->id);
                $data['pin_code'] = Hash::make($newPin);
            } else {
                // Jeśli pusty string/null -> usuwamy PIN
                $data['pin_code'] = null;
            }
        }

        $user->update($data);

        return new UserResource($user);
    }

    /**
     * Helper: Sprawdź czy PIN jest unikalny w bazie (porównując hashe)
     */
    private function ensurePinIsUnique(string $plainPin, ?int $ignoreUserId = null): void
    {
        // Pobierz wszystkich użytkowników, którzy mają PIN, z wyłączeniem edytowanego
        $query = User::whereNotNull('pin_code');

        if ($ignoreUserId) {
            $query->where('id', '!=', $ignoreUserId);
        }

        // Pobieramy tylko niezbędne pola dla wydajności (chunkowanie przy dużej bazie)
// Przy małej/średniej firmie (do kilkuset pracowników) full scan jest OK.
        $usersWithPin = $query->get(['id', 'pin_code']);

        foreach ($usersWithPin as $otherUser) {
            if (Hash::check($plainPin, $otherUser->pin_code)) {
                throw ValidationException::withMessages([
                    'pin_code' => ['Ten kod PIN jest już przypisany do innego pracownika.'],
                ]);
            }
        }
    }

    /**
     * Usuwanie użytkownika
     */
    public function destroy(User $user)
    {
        if ($user->id === auth()->id()) {
            return response()->json(['message' => 'Nie możesz usunąć własnego konta.'], 403);
        }

        $hasHistory = DB::table('production_services')->where('assigned_to_user_id', $user->id)->exists()
            || DB::table('quotations')->where('approved_by_user_id', $user->id)->exists();

        if ($hasHistory) {
            return response()->json([
                'message' => 'Nie można usunąć użytkownika, który posiada historię operacji. Zamiast tego dezaktywuj konto.'
            ], 422);
        }

        $user->delete();

        return response()->json(['message' => 'Użytkownik usunięty pomyślnie']);
    }

    /**
     * Zmiana statusu aktywności
     */
    public function toggleActive(User $user)
    {
        if ($user->id === auth()->id()) {
            return response()->json(['message' => 'Nie możesz zmienić statusu własnego konta.'], 403);
        }

        $user->update(['is_active' => !$user->is_active]);

        return response()->json([
            'message' => $user->is_active ? 'Użytkownik aktywowany' : 'Użytkownik dezaktywowany',
            'user' => new UserResource($user)
        ]);
    }
}


=================================================================================
FILE: app/Http/Controllers/API/VariantController.php
LOCATION: .//app/Http/Controllers/API/VariantController.php
=================================================================================

<?php

namespace App\Http\Controllers\API;

use App\Http\Controllers\Controller;
use App\Models\Order;
use App\Models\Variant;
use App\Enums\VariantType;
use App\Enums\VariantStatus;
use App\Enums\MaterialStatus;
use Illuminate\Http\Request;
use Illuminate\Validation\Rule;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;

class VariantController extends Controller
{
    // =========================================================================
    // INDEX
    // =========================================================================

    /**
     * Lista wszystkich grup i wariantów dla zamówienia (plaska lista).
     * Frontend sam buduje drzewo na podstawie parent_variant_id.
     *
     * GET /api/orders/{order}/variants
     */
    public function index(Order $order)
    {
        $variants = $order->variants()
            ->with(['parentVariant', 'childVariants'])
            ->orderBy('variant_number')
            ->get();

        return response()->json($variants);
    }

    // =========================================================================
    // SHOW
    // =========================================================================

    /**
     * Szczegoly wariantu lub grupy.
     *
     * GET /api/variants/{variant}
     */
    public function show(Variant $variant)
    {
        $variant->load([
            'order.customer',
            'parentVariant',
            'childVariants',
            'productionOrder.services.assignedWorker',
            'productionOrder.services.workstation',
            'deliveries',
        ]);

        return response()->json($variant);
    }

    // =========================================================================
    // STORE — TWORZENIE GRUPY
    // =========================================================================

    /**
     * Utwórz nową GRUPĘ dla zamówienia.
     *
     * Grupy to kontenery — nie mają wycen, materiałów ani produkcji.
     * Backend automatycznie nadaje kolejną wolną literę (A, B, C...).
     * is_group=true, quantity=0.
     *
     * POST /api/orders/{order}/variants
     * Payload: { name, description? }
     */
    public function store(Request $request, Order $order)
    {
        $validated = $request->validate([
            'name'        => 'required|string|max:255',
            'description' => 'nullable|string',
        ]);

        // Następna wolna litera (pomija zajęte przez grupy top-level)
        $existingLetters = $order->variants()
            ->whereNull('parent_variant_id')
            ->whereRaw('LENGTH(variant_number) = 1')
            ->pluck('variant_number')
            ->toArray();

        $letter = 'A';
        while (in_array($letter, $existingLetters)) {
            $letter = chr(ord($letter) + 1);
        }

        $group = $order->variants()->create([
            'is_group'        => true,
            'variant_number'  => $letter,
            'name'            => $validated['name'],
            'description'     => $validated['description'] ?? null,
            'quantity'        => 0,
            'type'            => VariantType::SERIAL, // Grupy maja domyslnie SERIAL — nie ma znaczenia
            'status'          => VariantStatus::DRAFT,
            'parent_variant_id' => null,
        ]);

        return response()->json([
            'message' => 'Grupa utworzona pomyslnie',
            'data'    => $group,
        ], 201);
    }

    // =========================================================================
    // STORE CHILD — TWORZENIE WARIANTU W GRUPIE
    // =========================================================================

    /**
     * Utwórz WARIANT jako dziecko grupy lub innego wariantu.
     *
     * Backend automatycznie nadaje numer wg reguly:
     *   A (bez cyfry)  → A1, A2, A3 (separator brak)
     *   A1 (z cyfra)   → A1_1, A1_2  (separator _)
     *
     * POST /api/orders/{order}/variants/{parent}/children
     * Payload: { name, quantity (>=1), type (SERIAL|PROTOTYPE), description? }
     */
    public function storeChild(Request $request, Order $order, Variant $parent)
    {
        // Waliduj ze parent nalezy do tego zamowienia
        if ($parent->order_id !== $order->id) {
            return response()->json([
                'message' => 'Rodzic nie nalezy do tego zamowienia.',
            ], 422);
        }

        $validated = $request->validate([
            'name'        => 'required|string|max:255',
            'quantity'    => 'required|integer|min:1',
            'type'        => ['required', Rule::enum(VariantType::class)],
            'description' => 'nullable|string',
        ]);

        $variantNumber = $this->nextChildNumber($parent);

        $variant = $order->variants()->create([
            'is_group'         => false,
            'parent_variant_id' => $parent->id,
            'variant_number'   => $variantNumber,
            'name'             => $validated['name'],
            'quantity'         => $validated['quantity'],
            'type'             => $validated['type'],
            'description'      => $validated['description'] ?? null,
            'status'           => VariantStatus::DRAFT,
            'is_approved'      => false,
        ]);

        $variant->load('parentVariant');

        return response()->json([
            'message' => 'Wariant utworzony pomyslnie',
            'data'    => $variant,
        ], 201);
    }

    // =========================================================================
    // UPDATE
    // =========================================================================

    /**
     * Aktualizuj grupe lub wariant.
     *
     * Blokujemy konwersje miedzy typami (is_group nie moze sie zmienic).
     *
     * PUT /api/variants/{variant}
     */
    public function update(Request $request, Variant $variant)
    {
        if ($variant->isGroup()) {
            // Grupy: tylko nazwa i opis
            $validated = $request->validate([
                'name'        => 'sometimes|string|max:255',
                'description' => 'nullable|string',
            ]);
        } else {
            // Warianty: pelna edycja
            $validated = $request->validate([
                'name'          => 'sometimes|string|max:255',
                'quantity'      => 'sometimes|integer|min:1',
                'description'   => 'nullable|string',
                'type'          => ['sometimes', Rule::enum(VariantType::class)],
                'status'        => ['sometimes', Rule::enum(VariantStatus::class)],
                'is_approved'   => 'boolean',
                'feedback_notes' => 'nullable|string',
            ]);
        }

        $variant->update($validated);

        return response()->json([
            'message' => 'Zapisano pomyslnie',
            'data'    => $variant->fresh(),
        ]);
    }

    // =========================================================================
    // DESTROY
    // =========================================================================

    /**
     * Usun wariant lub grupe.
     *
     * Dla GRUP z dziecmi wymagany parametr ?force=true.
     * Bez niego backend zwraca 422.
     * Z force=true kasuje grupe i cale drzewo potomkow rekurencyjnie.
     *
     * Dla WARIANTOW — blokuje usuniecie jesli sa w produkcji (nie DRAFT/CANCELLED).
     *
     * DELETE /api/variants/{variant}?force=true
     */
    public function destroy(Request $request, Variant $variant)
    {
        $force = $request->boolean('force', false);

        return DB::transaction(function () use ($variant, $force) {

            if ($variant->isGroup()) {
                // Laduj dzieci
                $variant->load('childVariants');
                $hasChildren = $variant->childVariants->isNotEmpty();

                if ($hasChildren && !$force) {
                    return response()->json([
                        'message' => 'Grupa ma warianty. Uzyj ?force=true aby usunac grupe razem z calym drzewem.',
                        'children_count' => $variant->childVariants->count(),
                    ], 422);
                }

                if ($hasChildren) {
                    // Usun rekurencyjnie — wszystkich potomkow
                    $this->deleteDescendants($variant);
                }

                $variant->delete();

                return response()->json([
                    'message' => 'Grupa i jej zawartosc zostaly usuniete.',
                ]);
            }

            // Wariant: blokuj usuniecie jesli jest w produkcji
            $blocked = [VariantStatus::PRODUCTION, VariantStatus::COMPLETED];
            if (in_array($variant->status, $blocked)) {
                return response()->json([
                    'message' => 'Nie mozna usunac wariantu w trakcie lub po produkcji.',
                ], 400);
            }

            $variant->delete();

            return response()->json([
                'message' => 'Wariant zostal usuniety.',
            ]);
        });
    }

    /**
     * Rekurencyjnie usun wszystkich potomkow danego wezla.
     */
    private function deleteDescendants(Variant $parent): void
    {
        $parent->load('childVariants.childVariants');

        foreach ($parent->childVariants as $child) {
            $this->deleteDescendants($child);
            $child->delete();
        }
    }

    // =========================================================================
    // UPDATE STATUS
    // =========================================================================

    /**
     * Zmien status wariantu (niedostepne dla grup).
     *
     * PATCH /api/variants/{variant}/status
     */
    public function updateStatus(Request $request, Variant $variant)
    {
        if ($variant->isGroup()) {
            return response()->json([
                'message' => 'Grupy nie maja statusu produkcji.',
            ], 422);
        }

        $validated = $request->validate([
            'status' => ['required', Rule::enum(VariantStatus::class)],
        ]);

        $variant->update(['status' => $validated['status']]);

        return response()->json($variant);
    }

    // =========================================================================
    // REVIEW PROTOTYPE
    // =========================================================================

    /**
     * Recenzja prototypu (zatwierdzenie / odrzucenie).
     *
     * POST /api/variants/{variant}/review
     */
    public function reviewPrototype(Request $request, Variant $variant)
    {
        if ($variant->isGroup()) {
            return response()->json(['message' => 'Grupy nie moga byc prototypami.'], 422);
        }

        if (!$variant->isPrototype()) {
            return response()->json(['message' => 'To nie jest prototyp.'], 400);
        }

        $validated = $request->validate([
            'action'         => 'required|in:approve,reject',
            'feedback_notes' => 'nullable|string',
        ]);

        $variant->update([
            'is_approved'    => $validated['action'] === 'approve',
            'feedback_notes' => $validated['feedback_notes'] ?? $variant->feedback_notes,
        ]);

        return response()->json($variant);
    }

    // =========================================================================
    // DUPLICATE
    // =========================================================================

    /**
     * Duplikuj grupe lub wariant.
     *
     * POST /api/variants/{variant}/duplicate
     *
     * Dla GRUPY:
     *   { relation: "sibling", name, description?, copy_children }
     *   - Tworzy nowa grupe (kolejna litera)
     *   - copy_children=true → kopiuje cale drzewo wariantow rekurencyjnie
     *
     * Dla WARIANTU:
     *   { relation: "sibling"|"child", name, quantity, type, description?,
     *     copy_quotation, copy_materials }
     *   - sibling: nowy wariant w tej samej grupie
     *   - child: podwariant tego wariantu
     */
    public function duplicate(Request $request, Variant $variant)
    {
        try {
            if ($variant->isGroup()) {
                return $this->duplicateGroup($request, $variant);
            } else {
                return $this->duplicateVariant($request, $variant);
            }
        } catch (\Exception $e) {
            Log::error('Variant duplicate error: ' . $e->getMessage(), [
                'variant_id' => $variant->id,
                'trace'      => $e->getTraceAsString(),
            ]);

            return response()->json([
                'message' => 'Blad podczas duplikowania',
                'error'   => $e->getMessage(),
            ], 500);
        }
    }

    /**
     * Duplikuj GRUPE.
     *
     * Zawsze jako sibling (kolejna litera). Grupy nie moga byc dzieclmi innych grup.
     * Z copy_children=true kopiuje cale drzewo wariantow wewnatrz grupy.
     */
    private function duplicateGroup(Request $request, Variant $group)
    {
        $validated = $request->validate([
            'name'          => 'required|string|max:255',
            'description'   => 'nullable|string',
            'copy_children' => 'boolean',
        ]);

        return DB::transaction(function () use ($group, $validated) {
            $order = $group->order;

            // Nastepna wolna litera dla grupy top-level
            $existingLetters = $order->variants()
                ->whereNull('parent_variant_id')
                ->whereRaw('LENGTH(variant_number) = 1')
                ->pluck('variant_number')
                ->toArray();

            $newLetter = 'A';
            while (in_array($newLetter, $existingLetters)) {
                $newLetter = chr(ord($newLetter) + 1);
            }

            // Utwórz nowa grupe
            $newGroup = $order->variants()->create([
                'is_group'         => true,
                'parent_variant_id' => null,
                'variant_number'   => $newLetter,
                'name'             => $validated['name'],
                'description'      => $validated['description'] ?? $group->description,
                'quantity'         => 0,
                'type'             => VariantType::SERIAL,
                'status'           => VariantStatus::DRAFT,
            ]);

            // Kopiuj dzieci jesli copy_children=true
            if (!empty($validated['copy_children'])) {
                $group->load('childVariants');

                foreach ($group->childVariants as $child) {
                    $this->copyVariantUnderNewParent($child, $newGroup, $order, $newLetter);
                }
            }

            $newGroup->load('childVariants');

            return response()->json([
                'message'      => 'Grupa zduplikowana pomyslnie',
                'variant'      => $newGroup,
                'new_letter'   => $newLetter,
                'children_copied' => !empty($validated['copy_children'])
                    ? $newGroup->childVariants->count()
                    : 0,
            ], 201);
        });
    }

    /**
     * Rekurencyjnie kopiuje wariant (i jego dzieci) pod nowego rodzica.
     * Numer wariantu: podmien prefiks starego rodzica na nowy.
     *
     * Przyklad:
     *   Stary: A1 (rodzic A), Nowy rodzic B → B1
     *   Stary: A1_1 (rodzic A1), Nowy rodzic B1 → B1_1
     *
     * @param Variant $source      Zrodlowy wariant do skopiowania
     * @param Variant $newParent   Nowy rodzic (nowa grupa lub wariant)
     * @param Order   $order       Zamowienie docelowe
     * @param string  $oldPrefix   Stary prefix do podmiany (np. "A")
     */
    private function copyVariantUnderNewParent(
        Variant $source,
        Variant $newParent,
        Order $order,
        string $oldPrefix
    ): Variant {
        // Podmien pierwszy segment numeru (liter) na nowy prefix grupy
        $newParentNumber = $newParent->variant_number;
        $sourceNumber    = $source->variant_number;

        // Nowy numer: podmien stary prefix na nowy
        // A1 → B1, A1_1 → B1_1, A2 → B2
        $newNumber = $newParentNumber . substr($sourceNumber, strlen($oldPrefix));

        $newVariant = $order->variants()->create([
            'is_group'         => false,
            'parent_variant_id' => $newParent->id,
            'variant_number'   => $newNumber,
            'name'             => $source->name,
            'description'      => $source->description,
            'quantity'         => $source->quantity,
            'type'             => $source->type,
            'status'           => VariantStatus::DRAFT,
            'is_approved'      => false,
        ]);

        // Rekurencyjnie kopiuj dzieci
        $source->load('childVariants');
        foreach ($source->childVariants as $grandChild) {
            $this->copyVariantUnderNewParent($grandChild, $newVariant, $order, $oldPrefix);
        }

        return $newVariant;
    }

    /**
     * Duplikuj WARIANT jako brat (sibling) lub dziecko (child).
     */
    private function duplicateVariant(Request $request, Variant $variant)
    {
        $validated = $request->validate([
            'relation'       => 'required|in:sibling,child',
            'name'           => 'required|string|max:255',
            'quantity'       => 'required|integer|min:1',
            'type'           => ['required', Rule::enum(VariantType::class)],
            'copy_quotation' => 'boolean',
            'copy_materials' => 'boolean',
            'description'    => 'nullable|string',
        ]);

        return DB::transaction(function () use ($variant, $validated) {
            $order = $variant->order;

            // Oblicz numer i parent_id dla nowego wariantu
            if ($validated['relation'] === 'sibling') {
                $variantNumber  = $this->nextSiblingNumber($order, $variant);
                $parentVariantId = $variant->parent_variant_id;
            } else {
                $variantNumber  = $this->nextChildNumber($variant);
                $parentVariantId = $variant->id;
            }

            // Utwórz nowy wariant
            $newVariant = $order->variants()->create([
                'is_group'         => false,
                'parent_variant_id' => $parentVariantId,
                'variant_number'   => $variantNumber,
                'name'             => $validated['name'],
                'quantity'         => $validated['quantity'],
                'type'             => $validated['type'],
                'description'      => $validated['description'] ?? $variant->description,
                'status'           => VariantStatus::DRAFT,
                'is_approved'      => false,
            ]);

            // Kopiuj materialy
            if (!empty($validated['copy_materials'])) {
                foreach ($variant->materials()->get() as $material) {
                    $newVariant->materials()->create([
                        'assortment_id'         => $material->assortment_id,
                        'quantity'              => $material->quantity,
                        'unit'                  => $material->unit,
                        'unit_price'            => $material->unit_price,
                        'total_cost'            => $material->total_cost,
                        'status'                => MaterialStatus::NOT_ORDERED,
                        'quantity_in_stock'     => 0,
                        'quantity_ordered'      => 0,
                        'expected_delivery_date' => null,
                        'ordered_at'            => null,
                        'received_at'           => null,
                        'supplier'              => $material->supplier,
                        'notes'                 => $material->notes,
                    ]);
                }
            }

            // Kopiuj wycene
            if (!empty($validated['copy_quotation'])) {
                $sourceQuotation = $variant->approvedQuotation
                    ?? $variant->quotations()->with(['items.materials', 'items.services'])
                        ->orderBy('version_number', 'desc')
                        ->first();

                if ($sourceQuotation) {
                    if (!$sourceQuotation->relationLoaded('items')) {
                        $sourceQuotation->load(['items.materials', 'items.services']);
                    }

                    $newQuotation = $newVariant->quotations()->create([
                        'version_number'       => 1,
                        'total_materials_cost' => $sourceQuotation->total_materials_cost,
                        'total_services_cost'  => $sourceQuotation->total_services_cost,
                        'total_net'            => $sourceQuotation->total_net,
                        'total_gross'          => $sourceQuotation->total_gross,
                        'margin_percent'       => $sourceQuotation->margin_percent,
                        'notes'                => 'Skopiowane z ' . $variant->variant_number
                            . ($sourceQuotation->notes ? '. ' . $sourceQuotation->notes : ''),
                        'is_approved'          => false,
                        'approved_at'          => null,
                        'approved_by'          => null,
                    ]);

                    foreach ($sourceQuotation->items as $item) {
                        $newItem = $newQuotation->items()->create([
                            'materials_cost' => $item->materials_cost,
                            'services_cost'  => $item->services_cost,
                            'subtotal'       => $item->subtotal,
                        ]);

                        foreach ($item->materials as $mat) {
                            $newItem->materials()->create([
                                'assortment_item_id' => $mat->assortment_item_id,
                                'quantity'           => $mat->quantity,
                                'unit'               => $mat->unit,
                                'unit_price'         => $mat->unit_price,
                                'total_cost'         => $mat->total_cost,
                                'notes'              => $mat->notes,
                            ]);
                        }

                        foreach ($item->services as $svc) {
                            $newItem->services()->create([
                                'assortment_item_id'  => $svc->assortment_item_id,
                                'estimated_quantity'  => $svc->estimated_quantity,
                                'estimated_time_hours' => $svc->estimated_time_hours,
                                'unit'               => $svc->unit,
                                'unit_price'         => $svc->unit_price,
                                'total_cost'         => $svc->total_cost,
                                'notes'              => $svc->notes,
                            ]);
                        }
                    }
                }
            }

            $newVariant->load(['parentVariant', 'materials', 'quotations']);

            return response()->json([
                'message'        => 'Wariant zduplikowany pomyslnie',
                'variant'        => $newVariant,
                'variant_number' => $variantNumber,
                'relation'       => $validated['relation'],
            ], 201);
        });
    }

    // =========================================================================
    // HELPERS — NUMERACJA
    // =========================================================================

    /**
     * Nastepna wolna litera/numer dla BRATA zrodlowego wariantu.
     *
     * Jezeli zrodlo jest top-level → nastepna wolna litera wsrod grup (B, C, D...)
     * Jezeli zrodlo jest dzieckiem → nastepny numer wsrod rodzenstwa (A2, A3...)
     */
    private function nextSiblingNumber(Order $order, Variant $source): string
    {
        if ($source->parent_variant_id === null) {
            // Top-level: nastepna wolna litera
            $existing = $order->variants()
                ->whereNull('parent_variant_id')
                ->whereRaw('LENGTH(variant_number) = 1')
                ->pluck('variant_number')
                ->toArray();

            $letter = 'A';
            while (in_array($letter, $existing)) {
                $letter = chr(ord($letter) + 1);
            }
            return $letter;
        }

        // Dziecko: nastepny numer wsrod dzieci tego samego rodzica
        $parent = Variant::findOrFail($source->parent_variant_id);
        return $this->nextChildNumber($parent);
    }

    /**
     * Nastepny numer dziecka dla danego rodzica.
     *
     * Regula separatorow:
     *   Rodzic top-level (A, B)  → A1, A2, A3    (bez separatora)
     *   Rodzic 1-poziom (A1, B2) → A1_1, A1_2    (separator _)
     *
     * Selektor cyfry (czy rodzic juz "ma cyfre") decyduje o separatorze.
     */
    private function nextChildNumber(Variant $parent): string
    {
        $parentNumber = $parent->variant_number;

        // Jezeli rodzic zawiera cyfre — uzywamy _ jako separatora
        $isDeepParent = (bool) preg_match('/\d/', $parentNumber);
        $separator    = $isDeepParent ? '_' : '';

        $children = Variant::where('parent_variant_id', $parent->id)
            ->pluck('variant_number')
            ->toArray();

        if (empty($children)) {
            return $parentNumber . $separator . '1';
        }

        $prefix = $parentNumber . $separator;
        $maxNum = 0;

        foreach ($children as $childNumber) {
            if (str_starts_with($childNumber, $prefix)) {
                $suffix = substr($childNumber, strlen($prefix));
                if (ctype_digit($suffix)) {
                    $maxNum = max($maxNum, (int) $suffix);
                }
            }
        }

        return $prefix . ($maxNum + 1);
    }
}


=================================================================================
FILE: app/Http/Controllers/API/VariantMaterialController.php
LOCATION: .//app/Http/Controllers/API/VariantMaterialController.php
=================================================================================

<?php

namespace App\Http\Controllers\API;

use App\Http\Controllers\Controller;
use App\Models\Variant;
use App\Models\VariantMaterial;
use App\Models\Assortment;
use App\Enums\MaterialStatus;
use App\Enums\AssortmentType;
use App\Enums\AssortmentUnit;
use Illuminate\Http\Request;
use Illuminate\Http\JsonResponse;
use Illuminate\Validation\Rule;

class VariantMaterialController extends Controller
{
    /**
     * Lista materiałów wariantu (produkcja seryjna)
     *
     * GET /api/variants/{variant}/materials
     */
    public function index(Variant $variant): JsonResponse
    {
        $materials = $variant->materials()
            ->with('assortment')
            ->orderBy('created_at')
            ->get();

        return response()->json([
            'data' => $materials,
            'summary' => $variant->materials_status_summary,
            'total_cost' => $variant->total_materials_cost,
        ]);
    }

    /**
     * Dodaj materiał do wariantu
     *
     * POST /api/variants/{variant}/materials
     */
    public function store(Request $request, Variant $variant): JsonResponse
    {
        $validated = $request->validate([
            'assortment_id' => 'required|exists:assortment,id',
            'quantity' => 'required|numeric|min:0.01',
            'unit' => 'required|string|max:10',
            'unit_price' => 'required|numeric|min:0',
            'status' => ['nullable', Rule::enum(MaterialStatus::class)],
            'expected_delivery_date' => 'nullable|date',
            'ordered_at' => 'nullable|date',
            'quantity_in_stock' => 'nullable|numeric|min:0',
            'quantity_ordered' => 'nullable|numeric|min:0',
            'supplier' => 'nullable|string|max:255',
            'notes' => 'nullable|string',
        ]);

        // Automatyczne obliczenie total_cost
        $validated['total_cost'] = $validated['quantity'] * $validated['unit_price'];
        $validated['status'] = $validated['status'] ?? MaterialStatus::NOT_ORDERED->value;

        $material = $variant->materials()->create($validated);
        $material->load('assortment');

        return response()->json($material, 201);
    }

    /**
     * Szczegóły materiału
     *
     * GET /api/variant-materials/{material}
     */
    public function show(VariantMaterial $material): JsonResponse
    {
        $material->load('assortment', 'variant');
        return response()->json($material);
    }

    /**
     * Aktualizuj materiał wariantu
     *
     * PUT /api/variant-materials/{material}
     */
    public function update(Request $request, VariantMaterial $material): JsonResponse
    {
        $validated = $request->validate([
            'assortment_id' => 'sometimes|exists:assortment,id',
            'quantity' => 'sometimes|numeric|min:0.01',
            'unit' => 'sometimes|string|max:10',
            'unit_price' => 'sometimes|numeric|min:0',
            'status' => ['sometimes', Rule::enum(MaterialStatus::class)],
            'expected_delivery_date' => 'nullable|date',
            'ordered_at' => 'nullable|date',
            'received_at' => 'nullable|date',
            'quantity_in_stock' => 'sometimes|numeric|min:0',
            'quantity_ordered' => 'sometimes|numeric|min:0',
            'supplier' => 'nullable|string|max:255',
            'notes' => 'nullable|string',
        ]);

        // Przelicz koszt jeśli zmieniono ilość lub cenę
        $quantity = $validated['quantity'] ?? $material->quantity;
        $unitPrice = $validated['unit_price'] ?? $material->unit_price;
        $validated['total_cost'] = $quantity * $unitPrice;

        $material->update($validated);
        $material->load('assortment');

        return response()->json($material);
    }

    /**
     * Usuń materiał wariantu
     *
     * DELETE /api/variant-materials/{material}
     */
    public function destroy(VariantMaterial $material): JsonResponse
    {
        $material->delete();

        return response()->json([
            'message' => 'Materiał usunięty pomyślnie'
        ]);
    }

    /**
     * Zmień status materiału (szybka akcja)
     *
     * PATCH /api/variant-materials/{material}/status
     */
    public function updateStatus(Request $request, VariantMaterial $material): JsonResponse
    {
        $validated = $request->validate([
            'status' => ['required', Rule::enum(MaterialStatus::class)],
            'expected_delivery_date' => 'nullable|date',
            'ordered_at' => 'nullable|date',
            'received_at' => 'nullable|date',
            'quantity_in_stock' => 'nullable|numeric|min:0',
            'quantity_ordered' => 'nullable|numeric|min:0',
        ]);

        // Auto-fill dat w zależności od statusu
        $status = MaterialStatus::from($validated['status']);

        if ($status === MaterialStatus::ORDERED && !isset($validated['ordered_at'])) {
            $validated['ordered_at'] = now()->toDateString();
        }

        if ($status === MaterialStatus::IN_STOCK && !isset($validated['received_at'])) {
            $validated['received_at'] = now()->toDateString();
            $validated['quantity_in_stock'] = $material->quantity;
        }

        $material->update($validated);
        $material->load('assortment');

        return response()->json($material);
    }

    /**
     * Oznacz wszystkie materiały wariantu jako zamówione
     *
     * POST /api/variants/{variant}/materials/mark-all-ordered
     */
    public function markAllOrdered(Variant $variant): JsonResponse
    {
        $variant->materials()
            ->where('status', MaterialStatus::NOT_ORDERED)
            ->update([
                'status' => MaterialStatus::ORDERED,
                'ordered_at' => now()->toDateString(),
            ]);

        return response()->json([
            'message' => 'Wszystkie niezamówione materiały oznaczono jako zamówione',
            'summary' => $variant->fresh()->materials_status_summary,
        ]);
    }
    /**
     * Masowe dodawanie materiałów
     * Tworzy asortyment, jeśli nie istnieje.
     */
    /**
     * Masowe dodawanie materiałów
     * Tworzy asortyment, jeśli nie istnieje.
     */
    public function batchStore(Request $request, Variant $variant): JsonResponse
    {
        $request->validate([
            'items' => 'required|array',
            'items.*.name' => 'required|string|max:255',
            'items.*.quantity' => 'required|numeric|min:0',
            'items.*.unit' => 'required|string|max:10',
            'items.*.unit_price' => 'nullable|numeric|min:0', // NOWE
        ]);

        $createdMaterials = [];

        \DB::transaction(function () use ($request, $variant, &$createdMaterials) {
            foreach ($request->items as $itemData) {
                // 1. Sprawdź, czy podano cenę w imporcie
                $importedPrice = isset($itemData['unit_price']) ? (float) $itemData['unit_price'] : null;

                // 2. Znajdź lub utwórz Asortyment
                $assortment = Assortment::firstOrCreate(
                    [
                        'name' => $itemData['name'],
                        'type' => AssortmentType::MATERIAL
                    ],
                    [
                        'category' => 'Importowane',
                        'unit' => AssortmentUnit::tryFrom($itemData['unit']) ?? AssortmentUnit::SZT,
                        // Jeśli nowy asortyment i podano cenę, ustaw ją jako domyślną
                        'default_price' => $importedPrice ?? 0,
                        'description' => 'Utworzono automatycznie z importu',
                        'is_active' => true
                    ]
                );

                // 3. Ustal cenę dla tego konkretnego materiału wariantu
                // Priorytet: Cena z importu -> Cena domyślna asortymentu -> 0
                $unitPrice = $importedPrice ?? $assortment->default_price;

                // Opcjonalnie: Jeśli asortyment istniał, ale miał cenę 0, a teraz importujemy z ceną - można zaktualizować asortyment
                if ($assortment->default_price == 0 && $importedPrice !== null) {
                    $assortment->update(['default_price' => $importedPrice]);
                }

                $quantity = $itemData['quantity'];
                $totalCost = $quantity * $unitPrice;

                // 4. Utwórz materiał wariantu
                $material = $variant->materials()->create([
                    'assortment_id' => $assortment->id,
                    'quantity' => $quantity,
                    'unit' => $itemData['unit'],
                    'unit_price' => $unitPrice,
                    'total_cost' => $totalCost,
                    'status' => MaterialStatus::NOT_ORDERED,
                ]);

                $createdMaterials[] = $material;
            }
        });

        return response()->json([
            'message' => 'Pomyślnie zaimportowano ' . count($createdMaterials) . ' pozycji.',
            'count' => count($createdMaterials)
        ], 201);
    }
}


=================================================================================
FILE: app/Http/Controllers/API/WorkstationController.php
LOCATION: .//app/Http/Controllers/API/WorkstationController.php
=================================================================================

<?php

namespace App\Http\Controllers\API;

use App\Http\Controllers\Controller;
use App\Models\Workstation;
use App\Models\User;
use App\Enums\WorkstationType;
use App\Enums\UserRole;
use Illuminate\Http\Request;
use Illuminate\Validation\Rule;
use App\Enums\WorkstationStatus;

class WorkstationController extends Controller
{
    /**
     * Lista stanowisk z operatorami i aktualnym zadaniem.
     */
    public function index()
    {
        $workstations = Workstation::with(['operators', 'currentTask.productionOrder.variant'])
            ->orderBy('name')
            ->get();

        return response()->json($workstations);
    }

    /**
     * Tworzenie nowego stanowiska.
     */
    public function store(Request $request)
    {
        $validated = $request->validate([
            'name' => 'required|string|unique:workstations,name|max:255',
            'type' => ['required', Rule::enum(WorkstationType::class)],
            'location' => 'nullable|string|max:255',
            'status' => ['required', Rule::enum(WorkstationStatus::class)],
            'operator_ids' => 'nullable|array',
            'operator_ids.*' => 'exists:users,id'
        ]);

        $workstation = Workstation::create([
            'name' => $validated['name'],
            'type' => $validated['type'],
            'location' => $validated['location'],
            'status' => $validated['status'],
        ]);

        if (isset($validated['operator_ids'])) {
            $workstation->operators()->sync($validated['operator_ids']);
        }

        return response()->json($workstation->load('operators'), 201);
    }

    /**
     * Szczegóły stanowiska.
     */
    public function show(Workstation $workstation)
    {
        $workstation->load([
            'operators',
            'tasks' => function ($q) {
                $q->orderBy('created_at', 'desc')->limit(10);
            }
        ]);

        return response()->json($workstation);
    }

    /**
     * Aktualizacja stanowiska.
     */
    public function update(Request $request, Workstation $workstation)
    {
        $validated = $request->validate([
            'name' => ['required', 'string', 'max:255', Rule::unique('workstations')->ignore($workstation->id)],
            'type' => ['sometimes', Rule::enum(WorkstationType::class)],
            'location' => 'nullable|string|max:255',
            'status' => ['required', Rule::enum(WorkstationStatus::class)],
            'operator_ids' => 'nullable|array',
            'operator_ids.*' => 'exists:users,id'
        ]);

        $workstation->update([
            'name' => $validated['name'],
            'type' => $validated['type'] ?? $workstation->type,
            'location' => $validated['location'],
            'status' => $validated['status'],
        ]);

        if (isset($validated['operator_ids'])) {
            $workstation->operators()->sync($validated['operator_ids']);
        }

        return response()->json($workstation->load('operators'));
    }

    /**
     * Usuwanie stanowiska.
     */
    public function destroy(Workstation $workstation)
    {
        // Sprawdź czy stanowisko nie ma aktywnego zadania
        if ($workstation->current_task_id) {
            return response()->json([
                'message' => 'Nie można usunąć stanowiska, które wykonuje zadanie.'
            ], 400);
        }

        $workstation->operators()->detach();
        $workstation->delete();

        return response()->json(['message' => 'Stanowisko usunięte pomyślnie']);
    }

    /**
     * Lista pracowników
     */
    public function workers()
    {
        // $workers = User::where('role', UserRole::PRODUCTION_EMPLOYEE)
        //     ->where('is_active', true)
        //     ->select('id', 'name', 'email')
        //     ->orderBy('name')
        //     ->get();

        $workers = User::where('is_active', true)
            ->select('id', 'name', 'email', 'role') // Dodałem 'role' żebyś widział kto to
            ->orderBy('name')
            ->get();

        return response()->json($workers);
    }

    public function attachService(Request $request, Workstation $workstation)
    {
        $request->validate(['assortment_id' => 'required|exists:assortment,id']);
        // Sprawdź czy to usługa
        $service = \App\Models\Assortment::findOrFail($request->assortment_id);
        if ($service->type !== \App\Enums\AssortmentType::SERVICE) {
            return response()->json(['message' => 'Można przypisać tylko usługi'], 400);
        }

        $workstation->allowedServices()->syncWithoutDetaching([$request->assortment_id]);
        return response()->json(['message' => 'Usługa przypisana']);
    }

    public function detachService(Workstation $workstation, $assortmentId)
    {
        $workstation->allowedServices()->detach($assortmentId);
        return response()->json(['message' => 'Usługa odpięta']);
    }

    public function getServices(Workstation $workstation)
    {
        return response()->json($workstation->allowedServices);
    }

    /**
     * NOWA METODA: Pobierz stanowiska przypisane do zalogowanego użytkownika.
     * Używane w panelu RCP.
     */
    public function forCurrentUser(Request $request)
    {
        $user = $request->user();

        // Jeśli to Admin/Manager, może widzieć wszystkie (opcjonalne, zależnie od logiki biznesowej)
        // Tutaj zakładamy, że na RCP widzi tylko swoje przypisane:

        $workstations = $user->workstations()
            ->with(['currentTask.productionOrder.variant']) // Załaduj aktywne zadania
            ->orderBy('name')
            ->get();

        return response()->json($workstations);
    }
}


=================================================================================
FILE: app/Enums/AssortmentHistoryAction.php
LOCATION: .//app/Enums/AssortmentHistoryAction.php
=================================================================================

<?php

namespace App\Enums;

enum AssortmentHistoryAction: string
{
    case CREATED = 'CREATED';
    case UPDATED = 'UPDATED';
    case DELETED = 'DELETED';
    case ACTIVATED = 'ACTIVATED';
    case DEACTIVATED = 'DEACTIVATED';

    public function label(): string
    {
        return match ($this) {
            self::CREATED => 'Utworzono',
            self::UPDATED => 'Zaktualizowano',
            self::DELETED => 'Usunięto',
            self::ACTIVATED => 'Aktywowano',
            self::DEACTIVATED => 'Dezaktywowano',
        };
    }
}


=================================================================================
FILE: app/Enums/AssortmentType.php
LOCATION: .//app/Enums/AssortmentType.php
=================================================================================

<?php
namespace App\Enums;

enum AssortmentType: string
{
    case MATERIAL = 'MATERIAL';
    case SERVICE = 'SERVICE';

    public function label(): string
    {
        return match ($this) {
            self::MATERIAL => 'Materiał',
            self::SERVICE => 'Usługa',
        };
    }
}


=================================================================================
FILE: app/Enums/AssortmentUnit.php
LOCATION: .//app/Enums/AssortmentUnit.php
=================================================================================

<?php

namespace App\Enums;

enum AssortmentUnit: string
{
    case SZT = 'SZT';
    case MB = 'MB';
    case M2 = 'M2';
    case KG = 'KG';
    case H = 'H';
    case KPL = 'KPL';
    case ROL = 'ROL';
    case OP = 'OP';
    case L = 'L';

    public function label(): string
    {
        return match ($this) {
            self::H => 'h',
            self::KG => 'kg',
            self::KPL => 'kpl.',
            self::L => 'litr',
            self::M2 => 'm²',
            self::MB => 'mb.',
            self::OP => 'opak.',
            self::ROL => 'rolka',
            self::SZT => 'szt.',
        };
    }
}


=================================================================================
FILE: app/Enums/CustomerType.php
LOCATION: .//app/Enums/CustomerType.php
=================================================================================

<?php

namespace App\Enums;

enum CustomerType: string
{
    case B2B = 'B2B';
    case B2C = 'B2C';

    public function label(): string
    {
        return match ($this) {
            self::B2B => 'Firma (B2B)',
            self::B2C => 'Klient Indywidualny (B2C)',
        };
    }
}


=================================================================================
FILE: app/Enums/DeliveryStatus.php
LOCATION: .//app/Enums/DeliveryStatus.php
=================================================================================

<?php

namespace App\Enums;

enum DeliveryStatus: string
{
    case SCHEDULED = 'SCHEDULED';
    case IN_TRANSIT = 'IN_TRANSIT';
    case DELIVERED = 'DELIVERED';
    case CANCELLED = 'CANCELLED';

    public function label(): string
    {
        return match ($this) {
            self::SCHEDULED => 'Zaplanowana',
            self::IN_TRANSIT => 'W transporcie',
            self::DELIVERED => 'Dostarczona',
            self::CANCELLED => 'Anulowana',
        };
    }

    public function color(): string
    {
        return match ($this) {
            self::SCHEDULED => 'blue',
            self::IN_TRANSIT => 'orange',
            self::DELIVERED => 'green',
            self::CANCELLED => 'red',
        };
    }
}


=================================================================================
FILE: app/Enums/EventType.php
LOCATION: .//app/Enums/EventType.php
=================================================================================

<?php

namespace App\Enums;

enum EventType: string
{
    case START = 'START';
    case PAUSE = 'PAUSE';
    case RESUME = 'RESUME';
    case STOP = 'STOP';

    public function label(): string
    {
        return match ($this) {
            self::START => 'Rozpoczęcie',
            self::PAUSE => 'Pauza',
            self::RESUME => 'Wznowienie',
            self::STOP => 'Zakończenie',
        };
    }
}


=================================================================================
FILE: app/Enums/InvoiceStatus.php
LOCATION: .//app/Enums/InvoiceStatus.php
=================================================================================

<?php

namespace App\Enums;

enum InvoiceStatus: string
{
    case ISSUED = 'ISSUED';
    case PAID = 'PAID';
    case OVERDUE = 'OVERDUE';
    case CANCELLED = 'CANCELLED';

    public function label(): string
    {
        return match ($this) {
            self::ISSUED => 'Wystawiona',
            self::PAID => 'Opłacona',
            self::OVERDUE => 'Przeterminowana',
            self::CANCELLED => 'Anulowana',
        };
    }

    public function color(): string
    {
        return match ($this) {
            self::ISSUED => 'blue',
            self::PAID => 'green',
            self::OVERDUE => 'red',
            self::CANCELLED => 'gray',
        };
    }
}


=================================================================================
FILE: app/Enums/MaterialStatus.php
LOCATION: .//app/Enums/MaterialStatus.php
=================================================================================

<?php

namespace App\Enums;

enum MaterialStatus: string
{
    case NOT_ORDERED = 'NOT_ORDERED';
    case ORDERED = 'ORDERED';
    case PARTIALLY_IN_STOCK = 'PARTIALLY_IN_STOCK';
    case IN_STOCK = 'IN_STOCK';

    public function label(): string
    {
        return match ($this) {
            self::NOT_ORDERED => 'Niezamówiony',
            self::ORDERED => 'Zamówiony',
            self::PARTIALLY_IN_STOCK => 'Częściowo na stanie',
            self::IN_STOCK => 'Na stanie',
        };
    }

    public function color(): string
    {
        return match ($this) {
            self::NOT_ORDERED => 'red',
            self::ORDERED => 'orange',
            self::PARTIALLY_IN_STOCK => 'blue',
            self::IN_STOCK => 'green',
        };
    }

    public function icon(): string
    {
        return match ($this) {
            self::NOT_ORDERED => 'mdi-cart-outline',
            self::ORDERED => 'mdi-truck-fast-outline',
            self::PARTIALLY_IN_STOCK => 'mdi-package-variant',
            self::IN_STOCK => 'mdi-package-variant-closed-check',
        };
    }
}


=================================================================================
FILE: app/Enums/OrderOverallStatus.php
LOCATION: .//app/Enums/OrderOverallStatus.php
=================================================================================

<?php

namespace App\Enums;

enum OrderOverallStatus: string
{
    case DRAFT = 'DRAFT';
    case QUOTATION = 'QUOTATION';
    case PROTOTYPE = 'PROTOTYPE';
    case PRODUCTION = 'PRODUCTION';
    case DELIVERY = 'DELIVERY';
    case COMPLETED = 'COMPLETED';
    case CANCELLED = 'CANCELLED';

    public function label(): string
    {
        return match ($this) {
            self::DRAFT => 'Szkic',
            self::QUOTATION => 'Wycena',
            self::PROTOTYPE => 'Prototyp',
            self::PRODUCTION => 'Produkcja',
            self::DELIVERY => 'Dostawa',
            self::COMPLETED => 'Zakończone',
            self::CANCELLED => 'Anulowane',
        };
    }

    public function color(): string
    {
        return match ($this) {
            self::DRAFT => 'grey',
            self::QUOTATION => 'blue',
            self::PROTOTYPE => 'purple',
            self::PRODUCTION => 'orange',
            self::DELIVERY => 'cyan',
            self::COMPLETED => 'green',
            self::CANCELLED => 'red',
        };
    }

    // DODAJ IKONY
    public function icon(): string
    {
        return match ($this) {
            self::DRAFT => 'mdi-file-document-outline',
            self::QUOTATION => 'mdi-calculator',
            self::PROTOTYPE => 'mdi-test-tube',
            self::PRODUCTION => 'mdi-cog',
            self::DELIVERY => 'mdi-truck-delivery',
            self::COMPLETED => 'mdi-check-circle',
            self::CANCELLED => 'mdi-cancel',
        };
    }
}


=================================================================================
FILE: app/Enums/OrderPhase.php
LOCATION: .//app/Enums/OrderPhase.php
=================================================================================

<?php

namespace App\Enums;

enum OrderPhase: string
{
    case QUOTATION = 'quotation';
    case PROTOTYPE = 'prototype';
    case PRODUCTION = 'production';
    case DELIVERY = 'delivery';
    case COMPLETED = 'completed';
    case CANCELLED = 'cancelled';

    public function label(): string
    {
        return match ($this) {
            self::QUOTATION => 'Wycena',
            self::PROTOTYPE => 'Prototyp',
            self::PRODUCTION => 'Produkcja',
            self::DELIVERY => 'Dostawa',
            self::COMPLETED => 'Zakończone',
            self::CANCELLED => 'Anulowane',
        };
    }
}


=================================================================================
FILE: app/Enums/OrderPriority.php
LOCATION: .//app/Enums/OrderPriority.php
=================================================================================

<?php

namespace App\Enums;

/**
 * Priorytet zamówienia
 */
enum OrderPriority: string
{
    case LOW = 'LOW';
    case NORMAL = 'NORMAL';
    case HIGH = 'HIGH';
    case URGENT = 'URGENT';

    /**
     * Etykieta do wyświetlania
     */
    public function label(): string
    {
        return match ($this) {
            self::LOW => 'Niski',
            self::NORMAL => 'Normalny',
            self::HIGH => 'Wysoki',
            self::URGENT => 'Pilny',
        };
    }

    /**
     * Kolor dla UI (Tailwind)
     */
    public function color(): string
    {
        return match ($this) {
            self::LOW => 'gray',
            self::NORMAL => 'blue',
            self::HIGH => 'orange',
            self::URGENT => 'red',
        };
    }
}


=================================================================================
FILE: app/Enums/PaymentMethod.php
LOCATION: .//app/Enums/PaymentMethod.php
=================================================================================

<?php

namespace App\Enums;

enum PaymentMethod: string
{
    case TRANSFER = 'TRANSFER';
    case CASH = 'CASH';
    case CARD = 'CARD';
    case OTHER = 'OTHER';

    public function label(): string
    {
        return match ($this) {
            self::TRANSFER => 'Przelew bankowy',
            self::CASH => 'Gotówka',
            self::CARD => 'Karta płatnicza',
            self::OTHER => 'Inny',
        };
    }
}


=================================================================================
FILE: app/Enums/PaymentStatus.php
LOCATION: .//app/Enums/PaymentStatus.php
=================================================================================

<?php

namespace App\Enums;

enum PaymentStatus: string
{
    case UNPAID = 'UNPAID';
    case PARTIAL = 'PARTIAL';
    case PAID = 'PAID';
    case OVERDUE = 'OVERDUE';

    public function label(): string
    {
        return match ($this) {
            self::UNPAID => 'Nieopłacone',
            self::PARTIAL => 'Częściowo opłacone',
            self::PAID => 'Opłacone',
            self::OVERDUE => 'Po terminie',
        };
    }

    public function color(): string
    {
        return match ($this) {
            self::UNPAID => 'grey',
            self::PARTIAL => 'orange',
            self::PAID => 'green',
            self::OVERDUE => 'red',
        };
    }

    // DODAJ IKONY
    public function icon(): string
    {
        return match ($this) {
            self::UNPAID => 'mdi-clock-outline',
            self::PARTIAL => 'mdi-clock-alert',
            self::PAID => 'mdi-check-circle',
            self::OVERDUE => 'mdi-alert-circle',
        };
    }
}


=================================================================================
FILE: app/Enums/ProductionStatus.php
LOCATION: .//app/Enums/ProductionStatus.php
=================================================================================

<?php

namespace App\Enums;

enum ProductionStatus: string
{
    case PLANNED = 'PLANNED';
    case IN_PROGRESS = 'IN_PROGRESS';
    case PAUSED = 'PAUSED';
    case COMPLETED = 'COMPLETED';
    case CANCELLED = 'CANCELLED';

    public function label(): string
    {
        return match ($this) {
            self::PLANNED => 'Planowane',
            self::IN_PROGRESS => 'W toku',
            self::PAUSED => 'Wstrzymane',
            self::COMPLETED => 'Zakończone',
            self::CANCELLED => 'Anulowane',
        };
    }
}


=================================================================================
FILE: app/Enums/TestResult.php
LOCATION: .//app/Enums/TestResult.php
=================================================================================

<?php

namespace App\Enums;

enum TestResult: string
{
    case PENDING = 'PENDING';
    case PASSED = 'PASSED';
    case FAILED = 'FAILED';

    public function label(): string
    {
        return match ($this) {
            self::PENDING => 'Oczekuje na test',
            self::PASSED => 'Zatwierdzony',
            self::FAILED => 'Odrzucony',
        };
    }

    public function color(): string
    {
        return match ($this) {
            self::PENDING => 'yellow',
            self::PASSED => 'green',
            self::FAILED => 'red',
        };
    }
}


=================================================================================
FILE: app/Enums/UserRole.php
LOCATION: .//app/Enums/UserRole.php
=================================================================================

<?php

namespace App\Enums;

enum UserRole: string
{
    case ADMIN = 'ADMIN';
    case PROJECT_MANAGER = 'PROJECT_MANAGER';
    case TRADER = 'TRADER'; // Handlowiec
    case PRODUCTION_EMPLOYEE = 'PRODUCTION_EMPLOYEE'; // Pracownik Produkcji (dawniej WORKER)
    case ADMINISTRATIVE_EMPLOYEE = 'ADMINISTRATIVE_EMPLOYEE'; // Pracownik Biurowy
    case LOGISTICS_SPECIALIST = 'LOGISTICS_SPECIALIST'; // Logistyk

    public function label(): string
    {
        return match ($this) {
            self::ADMIN => 'Administrator',
            self::PROJECT_MANAGER => 'Project Manager',
            self::TRADER => 'Handlowiec',
            self::PRODUCTION_EMPLOYEE => 'Pracownik Produkcji',
            self::ADMINISTRATIVE_EMPLOYEE => 'Pracownik Biurowy',
            self::LOGISTICS_SPECIALIST => 'Specjalista ds. Logistyki',
        };
    }
}


=================================================================================
FILE: app/Enums/VariantStatus.php
LOCATION: .//app/Enums/VariantStatus.php
=================================================================================

<?php

namespace App\Enums;

enum VariantStatus: string
{
    case DRAFT = 'DRAFT';
    case QUOTATION = 'QUOTATION';
    case PRODUCTION = 'PRODUCTION';
    case DELIVERY = 'DELIVERY';
    case COMPLETED = 'COMPLETED';
    case CANCELLED = 'CANCELLED';

    public function label(): string
    {
        return match ($this) {
            self::DRAFT => 'Szkic',
            self::QUOTATION => 'Wycena',
            self::PRODUCTION => 'Produkcja',
            self::DELIVERY => 'Dostawa',
            self::COMPLETED => 'Zakończone',
            self::CANCELLED => 'Anulowane',
        };
    }

    public function color(): string
    {
        return match ($this) {
            self::DRAFT => 'grey-lighten-1',
            self::QUOTATION => 'blue',
            self::PRODUCTION => 'orange',
            self::DELIVERY => 'cyan',
            self::COMPLETED => 'green',
            self::CANCELLED => 'red-darken-4',
        };
    }

    public function icon(): string
    {
        return match ($this) {
            self::DRAFT => 'mdi-pencil-outline',
            self::QUOTATION => 'mdi-calculator',
            self::PRODUCTION => 'mdi-cog',
            self::DELIVERY => 'mdi-truck-delivery',
            self::COMPLETED => 'mdi-check-circle',
            self::CANCELLED => 'mdi-cancel',
        };
    }
}


=================================================================================
FILE: app/Enums/VariantType.php
LOCATION: .//app/Enums/VariantType.php
=================================================================================

<?php

namespace App\Enums;

enum VariantType: string
{
    case PROTOTYPE = 'PROTOTYPE';
    case SERIAL = 'SERIAL';

    public function label(): string
    {
        return match ($this) {
            self::PROTOTYPE => 'Prototyp',
            self::SERIAL => 'Produkcja Seryjna',
        };
    }

    public function color(): string
    {
        return match ($this) {
            self::PROTOTYPE => 'purple',
            self::SERIAL => 'blue',
        };
    }
}


=================================================================================
FILE: app/Enums/WorkstationStatus.php
LOCATION: .//app/Enums/WorkstationStatus.php
=================================================================================

<?php

namespace App\Enums;

enum WorkstationStatus: string
{
    case IDLE = 'IDLE';
    case ACTIVE = 'ACTIVE';
    case PAUSED = 'PAUSED';
    case MAINTENANCE = 'MAINTENANCE';

    public function label(): string
    {
        return match ($this) {
            self::IDLE => 'Wolne',
            self::ACTIVE => 'Pracuje',
            self::PAUSED => 'Wstrzymane',
            self::MAINTENANCE => 'Konserwacja',
        };
    }

    public function color(): string
    {
        return match ($this) {
            self::IDLE => 'green',
            self::ACTIVE => 'blue',
            self::PAUSED => 'orange',
            self::MAINTENANCE => 'red',
        };
    }
}


=================================================================================
FILE: app/Enums/WorkstationType.php
LOCATION: .//app/Enums/WorkstationType.php
=================================================================================

<?php

namespace App\Enums;

enum WorkstationType: string
{
    case LASER = 'LASER';
    case CNC = 'CNC';
    case ASSEMBLY = 'ASSEMBLY';
    case PRINTING = 'PRINTING';
    case PAINTING = 'PAINTING';
    case PRODUCTION = 'PRODUCTION';
    case OTHER = 'OTHER';

    public function label(): string
    {
        return match ($this) {
            self::LASER => 'Laser',
            self::CNC => 'CNC',
            self::ASSEMBLY => 'Montaż',
            self::PRINTING => 'Drukarnia',
            self::PAINTING => 'Malarnia',
            self::PRODUCTION => 'Produkcja',
            self::OTHER => 'Inne',
        };
    }
}


=================================================================================
FILE: app/Services/RcpService.php
LOCATION: .//app/Services/RcpService.php
=================================================================================

<?php

namespace App\Services;

use App\Models\ProductionService;
use App\Models\ServiceTimeLog;
use App\Models\Workstation;
use App\Models\Variant;
use App\Models\Assortment;
use App\Enums\ProductionStatus;
use App\Enums\WorkstationStatus;
use App\Enums\EventType;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;

class RcpService
{
    // =========================================================================
    // HELPER — bezpieczne pobranie Unix timestamp z logu
    // =========================================================================

    /**
     * Zwraca Unix timestamp (int) z logu ServiceTimeLog.
     *
     * Używamy getRawOriginal() + strtotime() zamiast ->event_timestamp (Carbon cast).
     * Cast 'datetime' może tworzyć Carbon bez jawnej strefy czasowej, co powoduje
     * błędne diffInSeconds gdy APP_TIMEZONE != 'UTC'.
     *
     * MySQL timestamp column przechowuje czas w strefie sesji bazy danych.
     * Dodajemy ten sam suffix ' UTC' do obu timestampów (start i now) — offset
     * ewentualnie jest taki sam dla obu, więc RÓŻNICA jest zawsze poprawna.
     */
    private function logToUnixTimestamp(ServiceTimeLog $log): int
    {
        $raw = $log->getRawOriginal('event_timestamp'); // np. "2026-02-23 21:07:23"
        return (int) strtotime($raw . ' UTC');
    }

    // =========================================================================
    // START
    // =========================================================================

    /**
     * Rozpocznij pracę na stanowisku.
     *
     * Logika wyszukiwania zadania:
     *   PLANNED lub PAUSED → wznów (nie twórz nowego)
     *   COMPLETED lub brak  → utwórz nowy rekord
     *
     * PLANNED jest używany jako status "nowe, nierozpoczęte zadanie z wyceny".
     * PAUSED  oznacza zadanie które było uruchomione i zostało wstrzymane.
     * COMPLETED jest celowo pomijany — ponowny start = nowy wpis w bazie.
     */
    public function startWork(int $variantId, int $workstationId, int $serviceId, int $userId): array
    {
        return DB::transaction(function () use ($variantId, $workstationId, $serviceId, $userId) {
            // lockForUpdate() — zapobiega race condition gdy dwóch pracowników
            // jednocześnie próbuje zająć to samo stanowisko
            $workstation = Workstation::lockForUpdate()->findOrFail($workstationId);
            $variant = Variant::findOrFail($variantId);
            $service = Assortment::findOrFail($serviceId);

            // Sprawdź dostępność stanowiska
            if ($workstation->status !== WorkstationStatus::IDLE) {
                $currentTask = $workstation->currentTask;

                // Rzutowanie do int — Eloquent może zwrócić string z bazy
                $isSameContext = $currentTask
                    && (int) $currentTask->production_order_id === (int) optional($variant->productionOrder)->id
                    && $currentTask->service_name === $service->name
                    && (int) $currentTask->assigned_to_user_id === $userId;

                if ($isSameContext) {
                    // Idempotentne — podwójne kliknięcie, zwróć bez zmian
                    return [
                        'task' => $currentTask->load(['workstation', 'assignedWorker']),
                        'message' => 'Zadanie już trwa',
                        'current_task_id' => $currentTask->id,
                    ];
                }

                throw new \Exception('Stanowisko jest zajęte przez inne zadanie');
            }

            $productionOrder = $variant->productionOrder;
            if (!$productionOrder) {
                throw new \Exception('Brak zlecenia produkcyjnego dla tego wariantu');
            }

            // Szukaj tylko PLANNED lub PAUSED — COMPLETED celowo wykluczone
            $task = ProductionService::where('production_order_id', $productionOrder->id)
                ->where('service_name', $service->name)
                ->where('workstation_id', $workstationId)
                ->whereIn('status', [ProductionStatus::PLANNED, ProductionStatus::PAUSED])
                ->latest('id')
                ->first();

            if (!$task) {
                // Nowy przebieg — każdy start po COMPLETED tworzy oddzielny rekord
                $task = ProductionService::create([
                    'production_order_id' => $productionOrder->id,
                    'step_number' => $productionOrder->services()->count() + 1,
                    'service_name' => $service->name,
                    'workstation_id' => $workstationId,
                    'assigned_to_user_id' => $userId,
                    'estimated_quantity' => $service->default_quantity ?? 1,
                    'estimated_time_hours' => $service->estimated_time ?? 1,
                    'unit_price' => $service->default_price,
                    'estimated_cost' => ($service->default_quantity ?? 1) * $service->default_price,
                    'status' => ProductionStatus::PLANNED,
                    'actual_start_date' => now(),
                ]);
            }

            $task->update([
                'status' => ProductionStatus::IN_PROGRESS,
                // Zachowaj oryginalną datę startu przy wznowieniu po PAUSED
                'actual_start_date' => $task->actual_start_date ?? now(),
                'assigned_to_user_id' => $userId,
            ]);

            $workstation->update([
                'status' => WorkstationStatus::ACTIVE,
                'current_task_id' => $task->id,
            ]);

            ServiceTimeLog::create([
                'production_service_id' => $task->id,
                'user_id' => $userId,
                'event_type' => EventType::START,
                'event_timestamp' => now(),
                'elapsed_seconds' => 0,
            ]);

            Log::info("RCP: Zadanie #{$task->id} ({$service->name}) — START, użytkownik #{$userId}");

            return [
                'task' => $task->load(['workstation', 'assignedWorker']),
                'message' => 'Praca rozpoczęta',
                'current_task_id' => $task->id,
            ];
        });
    }

    // =========================================================================
    // STOP
    // =========================================================================

    /**
     * Zakończ pracę i oblicz wariancję czasu.
     *
     * Wzór kosztu: actual_cost = actual_time_hours × unit_price
     *
     * Obliczanie czasu przez Unix timestamps (time() i strtotime(raw . ' UTC')):
     *   Eliminuje wszelkie problemy ze strefami czasowymi Carbon/Eloquent.
     *   Różnica Unix timestamps jest zawsze poprawna nawet przy niezgodności TZ,
     *   ponieważ ten sam offset jest dodany do obu timestamp'ów.
     */
    public function stopWork(int $taskId): array
    {
        return DB::transaction(function () use ($taskId) {
            // lockForUpdate() — zapobiega zdublowanemu STOP przy podwójnym kliknięciu
            $task = ProductionService::lockForUpdate()->findOrFail($taskId);

            if (!in_array($task->status, [ProductionStatus::IN_PROGRESS, ProductionStatus::PAUSED])) {
                throw new \Exception('Zadanie nie jest aktywne ani wstrzymane');
            }

            // Ostatni log START
            $startLog = ServiceTimeLog::where('production_service_id', $taskId)
                ->where('event_type', EventType::START)
                ->latest('event_timestamp')
                ->first();

            if (!$startLog) {
                throw new \Exception('Brak logu startu — nie można obliczyć czasu');
            }

            $startUnix = $this->logToUnixTimestamp($startLog);
            $nowUnix = time();
            $totalElapsed = max(0, $nowUnix - $startUnix);

            // Czas zakończonych pauz po ostatnim START
            $totalPauseSeconds = $this->calculatePauseSeconds($taskId, $startUnix);

            // Jeśli wciąż w pauzie — dolicz trwającą pauzę
            if ($task->status === ProductionStatus::PAUSED) {
                $openPause = ServiceTimeLog::where('production_service_id', $taskId)
                    ->where('event_type', EventType::PAUSE)
                    ->whereNull('elapsed_seconds')
                    ->latest('event_timestamp')
                    ->first();

                if ($openPause) {
                    $totalPauseSeconds += max(0, $nowUnix - $this->logToUnixTimestamp($openPause));
                }
            }

            // Czas netto (bez przerw)
            $actualSeconds = max(0, $totalElapsed - $totalPauseSeconds);
            $actualHours = round($actualSeconds / 3600, 2);

            // Wariancja czasu
            $estimatedHours = (float) $task->estimated_time_hours;
            $timeVariance = $actualHours - $estimatedHours;
            $variancePercent = $estimatedHours > 0
                ? ($timeVariance / $estimatedHours) * 100
                : 0;

            // Koszt rzeczywisty = czas × stawka
            $actualCost = round($actualHours * (float) $task->unit_price, 2);
            $costVariance = round($actualCost - (float) $task->estimated_cost, 2);

            $task->update([
                'status' => ProductionStatus::COMPLETED,
                'actual_end_date' => now(),
                'actual_time_hours' => $actualHours,
                'actual_cost' => $actualCost,
                'time_variance_hours' => round($timeVariance, 2),
                'cost_variance' => $costVariance,
                'variance_percent' => round($variancePercent, 2),
                'total_pause_duration_seconds' => $totalPauseSeconds,
            ]);

            if ($task->workstation) {
                $task->workstation->update([
                    'status' => WorkstationStatus::IDLE,
                    'current_task_id' => null,
                ]);
            }

            ServiceTimeLog::create([
                'production_service_id' => $task->id,
                'user_id' => $task->assigned_to_user_id,
                'event_type' => EventType::STOP,
                'event_timestamp' => now(),
                'elapsed_seconds' => $actualSeconds,
            ]);

            // Zaktualizuj łączny koszt rzeczywisty zlecenia
            $productionOrder = $task->productionOrder;
            if ($productionOrder) {
                $productionOrder->update([
                    'total_actual_cost' => $productionOrder->services()
                        ->whereNotNull('actual_cost')
                        ->sum('actual_cost'),
                ]);
            }

            Log::info(
                "RCP: Zadanie #{$task->id} — STOP. " .
                "Czas: {$actualHours}h (est: {$estimatedHours}h), " .
                "koszt: {$actualCost} zł, wariancja: " . round($variancePercent, 1) . '%'
            );

            return [
                'task' => $task,
                'actual_hours' => $actualHours,
                'estimated_hours' => $estimatedHours,
                'time_variance' => round($timeVariance, 2),
                'variance_percent' => round($variancePercent, 2),
                'actual_cost' => $actualCost,
                'cost_variance' => $costVariance,
                'message' => 'Praca zakończona',
            ];
        });
    }

    // =========================================================================
    // PAUSE
    // =========================================================================

    /**
     * Wstrzymaj pracę.
     * Stanowisko dostaje status PAUSED — zablokowane dla innych, ale nie pracuje.
     */
    public function pauseWork(int $taskId): array
    {
        $task = ProductionService::findOrFail($taskId);

        if ($task->status !== ProductionStatus::IN_PROGRESS) {
            throw new \Exception('Można wstrzymać tylko zadanie w toku');
        }

        $task->update(['status' => ProductionStatus::PAUSED]);

        if ($task->workstation) {
            $task->workstation->update(['status' => WorkstationStatus::PAUSED]);
        }

        // elapsed_seconds = null — czas pauzy obliczany przy RESUME przez parowanie
        ServiceTimeLog::create([
            'production_service_id' => $task->id,
            'user_id' => $task->assigned_to_user_id,
            'event_type' => EventType::PAUSE,
            'event_timestamp' => now(),
            'elapsed_seconds' => null,
        ]);

        return ['task' => $task, 'message' => 'Praca wstrzymana'];
    }

    // =========================================================================
    // RESUME
    // =========================================================================

    /**
     * Wznów pracę po przerwie.
     * Zamyka ostatnią otwartą pauzę — zapisuje jej czas trwania.
     */
    public function resumeWork(int $taskId): array
    {
        $task = ProductionService::findOrFail($taskId);

        if ($task->status !== ProductionStatus::PAUSED) {
            throw new \Exception('Można wznowić tylko wstrzymane zadanie');
        }

        $openPause = ServiceTimeLog::where('production_service_id', $taskId)
            ->where('event_type', EventType::PAUSE)
            ->whereNull('elapsed_seconds')
            ->latest('event_timestamp')
            ->first();

        if (!$openPause) {
            throw new \Exception('Brak logu pauzy — nie można wyliczyć czasu przerwy');
        }

        $pauseDuration = max(0, time() - $this->logToUnixTimestamp($openPause));
        $openPause->update(['elapsed_seconds' => $pauseDuration]);

        $task->update(['status' => ProductionStatus::IN_PROGRESS]);

        if ($task->workstation) {
            $task->workstation->update(['status' => WorkstationStatus::ACTIVE]);
        }

        ServiceTimeLog::create([
            'production_service_id' => $task->id,
            'user_id' => $task->assigned_to_user_id,
            'event_type' => EventType::RESUME,
            'event_timestamp' => now(),
            'elapsed_seconds' => null,
        ]);

        return ['task' => $task, 'message' => 'Praca wznowiona'];
    }

    // =========================================================================
    // PRYWATNE
    // =========================================================================

    /**
     * Oblicza łączny czas zakończonych pauz (pary PAUSE→RESUME) po danym Unix timestamp.
     *
     * Algorytm: sortuje PAUSE i RESUME chronologicznie, paruje je indeksem (i-ta PAUSE → i-ty RESUME).
     * Niezamknięte pauzy (bez RESUME) są pomijane — obsługuje je wywołujący (stopWork).
     */
    private function calculatePauseSeconds(int $taskId, int $afterUnix): int
    {
        // gmdate() zwraca UTC string — zgodny z tym co przechowuje MySQL timestamp
        $afterStr = gmdate('Y-m-d H:i:s', $afterUnix);

        $pauseLogs = ServiceTimeLog::where('production_service_id', $taskId)
            ->where('event_type', EventType::PAUSE)
            ->where('event_timestamp', '>', $afterStr)
            ->orderBy('event_timestamp')
            ->get();

        $resumeLogs = ServiceTimeLog::where('production_service_id', $taskId)
            ->where('event_type', EventType::RESUME)
            ->where('event_timestamp', '>', $afterStr)
            ->orderBy('event_timestamp')
            ->get();

        $total = 0;
        foreach ($pauseLogs as $i => $pause) {
            $resume = $resumeLogs->get($i);
            if ($resume) {
                $total += max(0, $this->logToUnixTimestamp($resume) - $this->logToUnixTimestamp($pause));
            }
        }

        return $total;
    }
}


=================================================================================
FILE: app/Services/SeriesService.php
LOCATION: .//app/Services/SeriesService.php
=================================================================================

<?php

namespace App\Services;

use App\Models\Order;
use App\Models\Variant;
use App\Models\Quotation;
use App\Models\QuotationItem;
use App\Models\QuotationItemMaterial;
use App\Models\QuotationItemService;
use App\Models\VariantMaterial;
use App\Enums\MaterialStatus;
use App\Enums\VariantStatus;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;

use App\Enums\PaymentStatus;
use App\Enums\OrderOverallStatus;
use App\Enums\OrderPriority;


/**
 * SeriesService — logika tworzenia nowych serii zamówień
 *
 * Seria = to samo zamówienie (ten sam order_number) produkowane kolejny raz.
 * Przykład: Z/0001/0001 → Z/0001/0002 → Z/0001/0003
 *
 * Przy tworzeniu nowej serii user może:
 *  - Stworzyć pustą serię (bez wariantów)
 *  - Skopiować wybrane warianty z poprzedniej serii
 *    - z opcją kopiowania wycen (quotations)
 *    - z opcją kopiowania materiałów (variant_materials)
 */
class SeriesService
{
    // =========================================================================
    // TWORZENIE NOWEJ SERII
    // =========================================================================

    /**
     * Utwórz nową serię dla danego zamówienia (tego samego order_number).
     *
     * @param Order $sourceOrder    - zamówienie źródłowe (ta sama seria lub dowolna)
     * @param array $orderData      - dane nowego zamówienia (description, planned_delivery_date, priority)
     * @param array|null $variantsToCopy - które warianty kopiować i co z nich brać
     *   Format:
     *   [
     *     ['source_variant_id' => 5, 'copy_quotation' => true,  'copy_materials' => false],
     *     ['source_variant_id' => 7, 'copy_quotation' => false, 'copy_materials' => true],
     *   ]
     *   null lub [] = pusta seria (żadnych wariantów)
     *
     * @return Order - nowo utworzone zamówienie (nowa seria)
     */
    public function createNewSeries(
        Order $sourceOrder,
        array $orderData,
        ?array $variantsToCopy = null
    ): Order {
        return DB::transaction(function () use ($sourceOrder, $orderData, $variantsToCopy) {

            // Użyj tego samego numeru zamówienia, wygeneruj kolejną serię
            $newSeries = Order::generateSeries($sourceOrder->order_number);

            // Utwórz nowe zamówienie (nową serię)
            $newOrder = Order::create([
                'customer_id' => $sourceOrder->customer_id,
                'order_number' => $sourceOrder->order_number,
                'series' => $newSeries,
                'description' => $orderData['description'] ?? $sourceOrder->description,
                'planned_delivery_date' => $orderData['planned_delivery_date'] ?? null,
                'priority' => OrderPriority::NORMAL,
                'overall_status' => OrderOverallStatus::DRAFT,
                'payment_status' => PaymentStatus::UNPAID,
            ]);

            Log::info(
                "SeriesService: Utworzono nową serię #{$newOrder->id} " .
                "({$newOrder->full_order_number}) na podstawie #{$sourceOrder->id} " .
                "({$sourceOrder->full_order_number})"
            );

            // Jeśli user podał warianty do skopiowania - kopiuj je
            if (!empty($variantsToCopy)) {
                foreach ($variantsToCopy as $variantConfig) {
                    $this->copyVariantToOrder(
                        sourceVariantId: $variantConfig['source_variant_id'],
                        targetOrder: $newOrder,
                        copyQuotation: (bool) ($variantConfig['copy_quotation'] ?? false),
                        copyMaterials: (bool) ($variantConfig['copy_materials'] ?? false)
                    );
                }
            }

            // Załaduj relacje dla odpowiedzi
            $newOrder->load(['customer', 'variants']);

            return $newOrder;
        });
    }

    // =========================================================================
    // KOPIOWANIE WARIANTU
    // =========================================================================

    /**
     * Skopiuj wariant z jednego zamówienia do innego.
     *
     * Zawsze kopiuje podstawowe dane wariantu (nazwa, opis, ilość, typ).
     * Opcjonalnie: wycena + materiały.
     *
     * @param int   $sourceVariantId  - ID wariantu źródłowego
     * @param Order $targetOrder      - zamówienie docelowe (nowa seria)
     * @param bool  $copyQuotation    - czy kopiować zatwierdzoną wycenę (lub najnowszą)
     * @param bool  $copyMaterials    - czy kopiować listę materiałów wariantu
     *
     * @return Variant - nowo utworzony wariant
     */
    public function copyVariantToOrder(
        int $sourceVariantId,
        Order $targetOrder,
        bool $copyQuotation = false,
        bool $copyMaterials = false
    ): Variant {
        // Załaduj wariant źródłowy z potrzebnymi relacjami
        $sourceVariant = Variant::with([
            'quotations.items.materials',
            'quotations.items.services',
            'materials',
        ])->findOrFail($sourceVariantId);

        // Sprawdź czy wariant należy do zamówienia z tym samym order_number
        // (zabezpieczenie przed kopiowaniem między różnymi zamówieniami)
        $sourceOrder = $sourceVariant->order;
        if ($sourceOrder->order_number !== $targetOrder->order_number) {
            throw new \InvalidArgumentException(
                "Wariant #{$sourceVariantId} należy do zamówienia " .
                "{$sourceOrder->full_order_number}, " .
                "które ma inny numer niż docelowe {$targetOrder->full_order_number}."
            );
        }

        // Ustal kolejny numer wariantu w zamówieniu docelowym
        $nextVariantNumber = $this->getNextVariantNumber($targetOrder);

        // Utwórz nowy wariant (reset statusu - zaczyna od nowa)
        $newVariant = Variant::create([
            'order_id' => $targetOrder->id,
            'parent_variant_id' => null,
            'variant_number' => $nextVariantNumber,
            'name' => $sourceVariant->name,
            'description' => $sourceVariant->description,
            'quantity' => $sourceVariant->quantity,
            'type' => $sourceVariant->type,
            'status' => VariantStatus::QUOTATION, // zawsze zaczyna od wyceny
            'is_approved' => false,
            'feedback_notes' => null,
            'approved_prototype_id' => null,
        ]);

        Log::info(
            "SeriesService: Skopiowano wariant #{$sourceVariant->id} " .
            "({$sourceVariant->name}) → #{$newVariant->id} " .
            "w zamówieniu #{$targetOrder->id} ({$targetOrder->full_order_number})"
        );

        // Kopiuj wycenę (jeśli zażądano)
        if ($copyQuotation) {
            $this->copyBestQuotation($sourceVariant, $newVariant);
        }

        // Kopiuj materiały (jeśli zażądano)
        if ($copyMaterials) {
            $this->copyVariantMaterials($sourceVariant, $newVariant);
        }

        return $newVariant->fresh(['quotations', 'materials']);
    }

    // =========================================================================
    // KOPIOWANIE WYCENY
    // =========================================================================

    /**
     * Skopiuj wycenę z wariantu źródłowego do docelowego.
     *
     * Priorytet wyboru źródła:
     *  1. Zatwierdzona wycena (is_approved = true) — najlepsza jakość danych
     *  2. Najnowsza wycena (max version_number) — jeśli żadna nie zatwierdzona
     *
     * Nowa wycena tworzona jest jako wersja 1, NIE zatwierdzona
     * (nowa seria = nowa wycena do zatwierdzenia).
     *
     * @param Variant $sourceVariant
     * @param Variant $targetVariant
     * @return Quotation|null - nowa wycena lub null jeśli źródło nie ma wycen
     */
    private function copyBestQuotation(Variant $sourceVariant, Variant $targetVariant): ?Quotation
    {
        // Wybierz najlepszą wycenę źródłową
        $sourceQuotation = $sourceVariant->quotations()
            ->with(['items.materials', 'items.services'])
            ->where('is_approved', true)
            ->first();

        // Jeśli brak zatwierdzonej — weź najnowszą
        if (!$sourceQuotation) {
            $sourceQuotation = $sourceVariant->quotations()
                ->with(['items.materials', 'items.services'])
                ->orderByDesc('version_number')
                ->first();
        }

        if (!$sourceQuotation) {
            Log::warning(
                "SeriesService: Wariant #{$sourceVariant->id} nie ma żadnej wyceny do skopiowania."
            );
            return null;
        }

        // Utwórz nową wycenę (wersja 1, niezatwierdzona)
        $newQuotation = Quotation::create([
            'variant_id' => $targetVariant->id,
            'version_number' => 1,
            'total_materials_cost' => $sourceQuotation->total_materials_cost,
            'total_services_cost' => $sourceQuotation->total_services_cost,
            'total_net' => $sourceQuotation->total_net,
            'total_gross' => $sourceQuotation->total_gross,
            'margin_percent' => $sourceQuotation->margin_percent,
            'is_approved' => false,  // Zawsze niezatwierdzona w nowej serii
            'approved_at' => null,
            'approved_by_user_id' => null,
            'notes' => $this->buildCopyNote($sourceQuotation, $sourceVariant),
        ]);

        // Kopiuj pozycje wyceny (items)
        foreach ($sourceQuotation->items as $sourceItem) {
            $newItem = QuotationItem::create([
                'quotation_id' => $newQuotation->id,
                'materials_cost' => $sourceItem->materials_cost,
                'services_cost' => $sourceItem->services_cost,
                'subtotal' => $sourceItem->subtotal,
            ]);

            // Kopiuj materiały pozycji
            foreach ($sourceItem->materials as $material) {
                QuotationItemMaterial::create([
                    'quotation_item_id' => $newItem->id,
                    'assortment_item_id' => $material->assortment_item_id,
                    'quantity' => $material->quantity,
                    'unit' => $material->unit,
                    'unit_price' => $material->unit_price,
                    'total_cost' => $material->total_cost,
                    'notes' => $material->notes,
                ]);
            }

            // Kopiuj usługi pozycji
            foreach ($sourceItem->services as $service) {
                QuotationItemService::create([
                    'quotation_item_id' => $newItem->id,
                    'assortment_item_id' => $service->assortment_item_id,
                    'estimated_quantity' => $service->estimated_quantity,
                    'estimated_time_hours' => $service->estimated_time_hours,
                    'unit' => $service->unit,
                    'unit_price' => $service->unit_price,
                    'total_cost' => $service->total_cost,
                    'notes' => $service->notes,
                ]);
            }
        }

        Log::info(
            "SeriesService: Skopiowano wycenę #{$sourceQuotation->id} " .
            "(v{$sourceQuotation->version_number}) → #{$newQuotation->id} (v1) " .
            "dla wariantu #{$targetVariant->id}"
        );

        return $newQuotation;
    }

    // =========================================================================
    // KOPIOWANIE MATERIAŁÓW
    // =========================================================================

    /**
     * Skopiuj materiały wariantu (variant_materials) ze źródłowego do docelowego.
     *
     * Kopiuje tylko definicję (asortyment, ilość, cena) — bez statusów logistycznych.
     * Nowe materiały zaczynają od NOT_ORDERED (nowa seria = nowe zamówienie materiałów).
     *
     * @param Variant $sourceVariant
     * @param Variant $targetVariant
     * @return int - liczba skopiowanych materiałów
     */
    private function copyVariantMaterials(Variant $sourceVariant, Variant $targetVariant): int
    {
        $sourceMaterials = $sourceVariant->materials;

        if ($sourceMaterials->isEmpty()) {
            Log::warning(
                "SeriesService: Wariant #{$sourceVariant->id} nie ma materiałów do skopiowania."
            );
            return 0;
        }

        $count = 0;

        foreach ($sourceMaterials as $sourceMaterial) {
            VariantMaterial::create([
                'variant_id' => $targetVariant->id,
                'assortment_id' => $sourceMaterial->assortment_id,
                'quantity' => $sourceMaterial->quantity,
                'unit' => $sourceMaterial->unit,
                'unit_price' => $sourceMaterial->unit_price,
                'total_cost' => $sourceMaterial->total_cost,
                // Resetuj status logistyczny — nowa seria, nowe zamówienie
                'status' => MaterialStatus::NOT_ORDERED,
                'notes' => $sourceMaterial->notes,
                // Daty i ilości — zerowane (nowa dostawa)
                'expected_delivery_date' => null,
                'ordered_at' => null,
                'received_at' => null,
                'quantity_in_stock' => 0,
                'quantity_ordered' => 0,
                'supplier' => $sourceMaterial->supplier,
            ]);
            $count++;
        }

        Log::info(
            "SeriesService: Skopiowano {$count} materiałów " .
            "z wariantu #{$sourceVariant->id} → #{$targetVariant->id}"
        );

        return $count;
    }

    // =========================================================================
    // POMOCNICZE
    // =========================================================================

    /**
     * Pobierz kolejny numer wariantu dla danego zamówienia.
     * Liczymy istniejące warianty i dodajemy 1.
     */
    private function getNextVariantNumber(Order $order): int
    {
        $maxNumber = Variant::where('order_id', $order->id)->max('variant_number');
        return $maxNumber ? $maxNumber + 1 : 1;
    }

    /**
     * Zbuduj notatkę informującą o źródle kopii wyceny.
     */
    private function buildCopyNote(Quotation $sourceQuotation, Variant $sourceVariant): string
    {
        $sourceOrder = $sourceVariant->order;
        return "[Kopia z {$sourceOrder->full_order_number}, " .
            "wariant #{$sourceVariant->variant_number} ({$sourceVariant->name}), " .
            "wycena v{$sourceQuotation->version_number}" .
            ($sourceQuotation->is_approved ? ', zatwierdzona' : '') .
            "]";
    }

    // =========================================================================
    // POBIERANIE SERII
    // =========================================================================

    /**
     * Pobierz wszystkie serie dla danego numeru zamówienia.
     * Zwraca kolekcję zamówień posortowanych rosnąco po serii.
     *
     * @param string $orderNumber - 4-cyfrowy numer zamówienia
     * @return \Illuminate\Database\Eloquent\Collection
     */
    public function getAllSeriesForOrderNumber(string $orderNumber)
    {
        return Order::with(['customer', 'variants'])
            ->where('order_number', $orderNumber)
            ->orderBy('series', 'asc')
            ->get();
    }

    /**
     * Pobierz warianty z zamówienia sformatowane do wyświetlenia w selektorze kopiowania.
     * Zawiera informację o tym, czy wariant ma wycenę i materiały.
     *
     * @param Order $order
     * @return \Illuminate\Database\Eloquent\Collection
     */
    public function getVariantsForCopySelector(Order $order)
    {
        return Variant::with(['approvedQuotation', 'materials'])
            ->where('order_id', $order->id)
            ->orderBy('variant_number')
            ->get()
            ->map(function (Variant $variant) {
                return [
                    'id' => $variant->id,
                    'variant_number' => $variant->variant_number,
                    'name' => $variant->name,
                    'quantity' => $variant->quantity,
                    'status' => $variant->status,
                    'type' => $variant->type,
                    // Czy jest co kopiować?
                    'has_quotation' => $variant->quotations()->exists(),
                    'has_approved_quotation' => $variant->approvedQuotation !== null,
                    'has_materials' => $variant->materials->isNotEmpty(),
                    'materials_count' => $variant->materials->count(),
                    // Info o najlepszej wycenie
                    'quotation_info' => $this->getQuotationInfo($variant),
                ];
            });
    }

    /**
     * Pomocnicza — informacje o wycenie wariantu dla selektora.
     */
    private function getQuotationInfo(Variant $variant): ?array
    {
        $approved = $variant->approvedQuotation;
        if ($approved) {
            return [
                'version' => $approved->version_number,
                'total_gross' => $approved->total_gross,
                'is_approved' => true,
            ];
        }

        $latest = $variant->quotations()->orderByDesc('version_number')->first();
        if ($latest) {
            return [
                'version' => $latest->version_number,
                'total_gross' => $latest->total_gross,
                'is_approved' => false,
            ];
        }

        return null;
    }
}


=================================================================================
FILE: routes/api.php
LOCATION: .//routes/api.php
=================================================================================

<?php

use Illuminate\Support\Facades\Route;
use App\Http\Controllers\API\AuthController;
use App\Http\Controllers\API\OrderController;
use App\Http\Controllers\API\OrderSeriesController;
use App\Http\Controllers\API\CustomerController;
use App\Http\Controllers\API\AssortmentController;
use App\Http\Controllers\API\QuotationController;
use App\Http\Controllers\API\VariantController;
use App\Http\Controllers\API\PrototypeController;
use App\Http\Controllers\API\MetadataController;
use App\Http\Controllers\API\NipController;
use App\Http\Controllers\API\WorkstationController;
use App\Http\Controllers\API\RcpController;
use App\Http\Controllers\API\RcpAdminController;
use App\Http\Controllers\API\UserController;
use App\Http\Controllers\API\VariantMaterialController;
use App\Http\Controllers\API\PrototypeMaterialController;
use App\Http\Controllers\API\OrderImageController;
use App\Http\Controllers\API\ProductionController;
use App\Http\Controllers\API\DeliveryController;

// =========================================================================
// PUBLICZNE — bez autoryzacji
// =========================================================================

Route::post('/login', [AuthController::class, 'login']);
Route::post('/logout', [AuthController::class, 'logout'])->middleware('auth:sanctum');
Route::post('/auth/login-pin', [AuthController::class, 'loginPin']);

// =========================================================================
// CHRONIONE — wymagają auth:sanctum
// =========================================================================

Route::middleware('auth:sanctum')->group(function () {

    Route::get('/user', [AuthController::class, 'me']);

    // =========================================================================
    // UŻYTKOWNICY
    // =========================================================================

    Route::patch('users/{user}/toggle-active', [UserController::class, 'toggleActive']);
    Route::apiResource('users', UserController::class);

    // =========================================================================
    // KLIENCI
    // =========================================================================

    Route::get('customers/for-select', [CustomerController::class, 'forSelect']);
    Route::get('customers/{customer}/statistics', [CustomerController::class, 'statistics']);
    Route::patch('customers/{customer}/toggle-active', [CustomerController::class, 'toggleActive']);
    Route::apiResource('customers', CustomerController::class);

    // =========================================================================
    // ZAMÓWIENIA
    // =========================================================================

    // Pomocniczy — podgląd następnego numeru (frontend info, nie rezerwuje numeru)
    Route::get('orders/next-number', [OrderController::class, 'nextNumber']);

    // Podsumowanie finansowe zamówienia (materiały + wyceny + koszty produkcji)
    Route::get('orders/{order}/financial-summary', [OrderController::class, 'financialSummary']);

    // ── SERIE ZAMÓWIEŃ ─────────────────────────────────────────────────────
    //
    // Uwaga: trasy z parametrami muszą być PRZED apiResource('orders'),
    // żeby Laravel nie traktował 'series' jako ID zamówienia.
    //
    // Pobierz wszystkie serie dla order_number zamówienia {order}
    Route::get('orders/{order}/series', [OrderSeriesController::class, 'index']);

    // Pobierz warianty danej serii do selektora kopiowania (CreateSeriesDialog)
    Route::get('orders/{order}/series/variants', [OrderSeriesController::class, 'variantsForSelector']);

    // Utwórz nową serię (pustą lub z kopiowaniem wybranych wariantów)
    Route::post('orders/{order}/series/create', [OrderSeriesController::class, 'create']);

    // CRUD zamówień
    Route::apiResource('orders', OrderController::class);

    // =========================================================================
    // ASORTYMENT (materiały + usługi)
    // =========================================================================

    Route::post('assortment/batch-check', [AssortmentController::class, 'batchCheckOrCreate']);
    Route::get('assortment/{assortment}/history', [AssortmentController::class, 'history']);
    Route::get('assortment-materials', [AssortmentController::class, 'materials']);
    Route::get('assortment-services', [AssortmentController::class, 'services']);
    Route::get('assortment-categories', [AssortmentController::class, 'categories']);
    Route::patch('assortment/{assortment}/toggle-active', [AssortmentController::class, 'toggleActive']);
    Route::apiResource('assortment', AssortmentController::class);

    // =========================================================================
    // WARIANTY PRODUKTOWE
    //
    // ARCHITEKTURA HIERARCHII:
    //
    //   Discriminator: quantity
    //     quantity = 0  → GRUPA   (kontener, nie jest produkowana)
    //     quantity ≥ 1  → WARIANT (ma lifecycle produkcji)
    //
    //   Drzewo przykładowe:
    //     A (quantity=0, GRUPA)
    //       A1 (quantity=10, WARIANT)
    //       A2 (quantity=5,  WARIANT)
    //         A2_1 (quantity=3, WARIANT podrzędny)
    //     B (quantity=0, GRUPA)
    //       B1 (quantity=8, WARIANT)
    //
    // =========================================================================

    // Pobierz wszystkie elementy (grupy + warianty) dla zamówienia — płaska lista
    Route::get('orders/{order}/variants', [VariantController::class, 'index']);

    // Utwórz nową GRUPĘ dla zamówienia (quantity=0 nadawane automatycznie przez backend)
    // Backend nadaje kolejną literę: A, B, C...
    // Payload: { name, description? }
    Route::post('orders/{order}/variants', [VariantController::class, 'store']);

    // Utwórz WARIANT jako dziecko istniejącej grupy lub wariantu
    // Backend nadaje numer wg reguły: A → A1, A2; A1 → A1_1, A1_2
    // Payload: { name, quantity (≥1), type (SERIAL|PROTOTYPE), description? }
    Route::post('orders/{order}/variants/{parent}/children', [VariantController::class, 'storeChild']);

    // Szczegóły wariantu lub grupy
    Route::get('variants/{variant}', [VariantController::class, 'show']);

    // Aktualizacja grupy lub wariantu
    // UWAGA: backend blokuje konwersję quantity=0 ↔ quantity≥1 (nie można zmieniać typu)
    Route::put('variants/{variant}', [VariantController::class, 'update']);

    // Usuń wariant lub grupę
    // ?force=true — wymagane dla grup z dziećmi; kasuje rekurencyjnie całe drzewo
    // Bez force=true backend zwraca 422 jeśli element ma dzieci
    Route::delete('variants/{variant}', [VariantController::class, 'destroy']);

    // Zmień status wariantu (tylko dla wariantów — grup nie dotyczą statusy)
    // Payload: { status: PENDING|IN_PROGRESS|COMPLETED|CANCELLED|... }
    Route::patch('variants/{variant}/status', [VariantController::class, 'updateStatus']);

    // Recenzja prototypu — zatwierdź lub odrzuć
    // Payload: { action: approve|reject, feedback_notes?: string }
    Route::post('variants/{variant}/review', [VariantController::class, 'reviewPrototype']);

    // Duplikuj wariant lub grupę
    // Dla wariantu: { relation: sibling|child, name, quantity, type, copy_quotation, copy_materials, description? }
    // Dla grupy:    { relation: sibling, name, copy_children, description? }
    Route::post('variants/{variant}/duplicate', [VariantController::class, 'duplicate']);

    // =========================================================================
    // MATERIAŁY WARIANTU (produkcja seryjna)
    // =========================================================================

    Route::get('variants/{variant}/materials', [VariantMaterialController::class, 'index']);
    Route::post('variants/{variant}/materials', [VariantMaterialController::class, 'store']);
    Route::post('variants/{variant}/materials/batch', [VariantMaterialController::class, 'batchStore']);
    Route::post('variants/{variant}/materials/mark-all-ordered', [VariantMaterialController::class, 'markAllOrdered']);
    Route::get('variant-materials/{material}', [VariantMaterialController::class, 'show']);
    Route::put('variant-materials/{material}', [VariantMaterialController::class, 'update']);
    Route::delete('variant-materials/{material}', [VariantMaterialController::class, 'destroy']);
    Route::patch('variant-materials/{material}/status', [VariantMaterialController::class, 'updateStatus']);

    // =========================================================================
    // WYCENY
    // =========================================================================

    // UWAGA: Wyceny tworzone są per WARIANT (nie per grupę).
    // Grupy nie mają wycen — wyceny dotyczą konkretnych wariantów produkcyjnych.
    Route::get('variants/{variant}/quotations', [QuotationController::class, 'index']);
    Route::post('variants/{variant}/quotations', [QuotationController::class, 'store']);
    Route::get('quotations/{quotation}', [QuotationController::class, 'show']);
    Route::put('quotations/{quotation}', [QuotationController::class, 'update']);
    Route::patch('quotations/{quotation}/approve', [QuotationController::class, 'approve']);
    Route::get('quotations/{quotation}/pdf', [QuotationController::class, 'downloadPdf']);
    Route::post('quotations/{quotation}/duplicate', [QuotationController::class, 'duplicate']);
    Route::post('quotations/{quotation}/export-materials', [QuotationController::class, 'exportMaterials']);

    // =========================================================================
    // PROTOTYPY
    // =========================================================================

    Route::get('variants/{variant}/prototypes', [PrototypeController::class, 'index']);
    Route::post('variants/{variant}/prototypes', [PrototypeController::class, 'store']);
    Route::get('prototypes/{prototype}', [PrototypeController::class, 'show']);
    Route::put('prototypes/{prototype}', [PrototypeController::class, 'update']);
    Route::patch('prototypes/{prototype}/approve', [PrototypeController::class, 'approve']);
    Route::patch('prototypes/{prototype}/reject', [PrototypeController::class, 'reject']);

    // =========================================================================
    // MATERIAŁY PROTOTYPU
    // =========================================================================

    Route::get('prototypes/{prototype}/materials', [PrototypeMaterialController::class, 'index']);
    Route::post('prototypes/{prototype}/materials', [PrototypeMaterialController::class, 'store']);
    Route::post('prototypes/{prototype}/materials/batch', [PrototypeMaterialController::class, 'batchStore']);
    Route::get('prototype-materials/{material}', [PrototypeMaterialController::class, 'show']);
    Route::put('prototype-materials/{material}', [PrototypeMaterialController::class, 'update']);
    Route::delete('prototype-materials/{material}', [PrototypeMaterialController::class, 'destroy']);
    Route::patch('prototype-materials/{material}/status', [PrototypeMaterialController::class, 'updateStatus']);

    // =========================================================================
    // ZDJĘCIA ZAMÓWIENIA
    // =========================================================================

    Route::get('orders/{order}/images', [OrderImageController::class, 'index']);
    Route::post('orders/{order}/images', [OrderImageController::class, 'store']);
    Route::delete('order-images/{image}', [OrderImageController::class, 'destroy']);

    // =========================================================================
    // PRODUKCJA
    // =========================================================================

    Route::get('variants/{variant}/production', [ProductionController::class, 'show']);
    Route::post('variants/{variant}/production', [ProductionController::class, 'store']);
    Route::get('production/{production}', [ProductionController::class, 'details']);
    Route::put('production/{production}', [ProductionController::class, 'update']);
    Route::get('production/{production}/services', [ProductionController::class, 'services']);
    Route::post('production/{production}/services', [ProductionController::class, 'addService']);
    Route::put('production-services/{service}', [ProductionController::class, 'updateService']);
    Route::delete('production-services/{service}', [ProductionController::class, 'deleteService']);

    // =========================================================================
    // DOSTAWY
    // =========================================================================

    Route::get('variants/{variant}/deliveries', [DeliveryController::class, 'index']);
    Route::post('variants/{variant}/deliveries', [DeliveryController::class, 'store']);
    Route::get('deliveries/{delivery}', [DeliveryController::class, 'show']);
    Route::put('deliveries/{delivery}', [DeliveryController::class, 'update']);
    Route::patch('deliveries/{delivery}/complete', [DeliveryController::class, 'complete']);
    Route::delete('deliveries/{delivery}', [DeliveryController::class, 'destroy']);

    // =========================================================================
    // RCP — Panel pracownika produkcyjnego
    //
    // Pracownik loguje się przez PIN, widzi swoje zadania, obsługuje timer.
    // =========================================================================

    // Sprawdź czy pracownik ma aktywne zadanie (po powrocie do aplikacji)
    Route::get('rcp/active-task', [RcpController::class, 'checkActiveTask']);

    // Szczegóły konkretnego zadania (z timerem)
    Route::get('rcp/tasks/{task}', [RcpController::class, 'getTaskDetails']);

    // Lista wariantów gotowych do obsługi przez pracownika
    Route::get('rcp/variants', [RcpController::class, 'getAvailableVariants']);

    // Cykl życia timera
    Route::post('rcp/start', [RcpController::class, 'start']);
    Route::post('rcp/stop/{task}', [RcpController::class, 'stop']);
    Route::post('rcp/pause/{task}', [RcpController::class, 'pause']);
    Route::post('rcp/resume/{task}', [RcpController::class, 'resume']);

    // =========================================================================
    // RCP ADMIN — zarządzanie zadaniami i ręczna korekta logów czasu
    // =========================================================================

    Route::get('admin/rcp/tasks', [RcpAdminController::class, 'index']);
    Route::put('admin/rcp/tasks/{task}', [RcpAdminController::class, 'update']);
    Route::get('admin/rcp/tasks/{task}/logs', [RcpAdminController::class, 'getLogs']);
    Route::post('admin/rcp/tasks/{task}/logs', [RcpAdminController::class, 'storeLog']);
    Route::put('admin/rcp/logs/{log}', [RcpAdminController::class, 'updateLog']);
    Route::delete('admin/rcp/logs/{log}', [RcpAdminController::class, 'destroyLog']);

    // =========================================================================
    // STANOWISKA PRACY
    // =========================================================================

    Route::apiResource('workstations', WorkstationController::class);
    Route::post('workstations/{workstation}/operators', [WorkstationController::class, 'addOperator']);
    Route::delete('workstations/{workstation}/operators/{user}', [WorkstationController::class, 'removeOperator']);

    // Usługi przypisane do stanowiska (co stanowisko może wykonywać)
    Route::get('workstations/{workstation}/services', [WorkstationController::class, 'services']);
    Route::post('workstations/{workstation}/services/{assortment}', [WorkstationController::class, 'attachService']);
    Route::delete('workstations/{workstation}/services/{assortment}', [WorkstationController::class, 'detachService']);

    // =========================================================================
    // INNE
    // =========================================================================

    // Metadata — statusy, typy, enumy (ładowane raz przy starcie aplikacji)
    Route::get('/metadata', [MetadataController::class, 'index']);

    // Lookup GUS po NIP (autocomplete przy tworzeniu klienta)
    Route::get('nip/{nip}', [NipController::class, 'lookup']);
});


=================================================================================
FILE: config/cors.php
LOCATION: .//config/cors.php
=================================================================================

<?php

return [
    'paths' => ['api/*', 'sanctum/csrf-cookie'],
    'allowed_methods' => ['*'],
    'allowed_origins' => ['http://localhost:5173', 'http://127.0.0.1:5173'],
    'allowed_origins_patterns' => [],
    'allowed_headers' => ['*'],
    'exposed_headers' => [],
    'max_age' => 0,
    'supports_credentials' => true,
];


=================================================================================
FILE: config/sanctum.php
LOCATION: .//config/sanctum.php
=================================================================================

<?php

use Laravel\Sanctum\Sanctum;

return [

    /*
    |--------------------------------------------------------------------------
    | Stateful Domains
    |--------------------------------------------------------------------------
    |
    | Requests from the following domains / hosts will receive stateful API
    | authentication cookies. Typically, these should include your local
    | and production domains which access your API via a frontend SPA.
    |
    */

    'stateful' => explode(',', env('SANCTUM_STATEFUL_DOMAINS', sprintf(
        '%s%s',
        'localhost,localhost:3000,127.0.0.1,127.0.0.1:8000,::1',
        Sanctum::currentApplicationUrlWithPort(),
        // Sanctum::currentRequestHost(),
    ))),

    /*
    |--------------------------------------------------------------------------
    | Sanctum Guards
    |--------------------------------------------------------------------------
    |
    | This array contains the authentication guards that will be checked when
    | Sanctum is trying to authenticate a request. If none of these guards
    | are able to authenticate the request, Sanctum will use the bearer
    | token that's present on an incoming request for authentication.
    |
    */

    'guard' => ['web'],

    /*
    |--------------------------------------------------------------------------
    | Expiration Minutes
    |--------------------------------------------------------------------------
    |
    | This value controls the number of minutes until an issued token will be
    | considered expired. This will override any values set in the token's
    | "expires_at" attribute, but first-party sessions are not affected.
    |
    */

    'expiration' => null,

    /*
    |--------------------------------------------------------------------------
    | Token Prefix
    |--------------------------------------------------------------------------
    |
    | Sanctum can prefix new tokens in order to take advantage of numerous
    | security scanning initiatives maintained by open source platforms
    | that notify developers if they commit tokens into repositories.
    |
    | See: https://docs.github.com/en/code-security/secret-scanning/about-secret-scanning
    |
    */

    'token_prefix' => env('SANCTUM_TOKEN_PREFIX', ''),

    /*
    |--------------------------------------------------------------------------
    | Sanctum Middleware
    |--------------------------------------------------------------------------
    |
    | When authenticating your first-party SPA with Sanctum you may need to
    | customize some of the middleware Sanctum uses while processing the
    | request. You may change the middleware listed below as required.
    |
    */

    'middleware' => [
        'authenticate_session' => Laravel\Sanctum\Http\Middleware\AuthenticateSession::class,
        'encrypt_cookies' => Illuminate\Cookie\Middleware\EncryptCookies::class,
        'validate_csrf_token' => Illuminate\Foundation\Http\Middleware\ValidateCsrfToken::class,
    ],

];


=================================================================================
FILE: config/database.php
LOCATION: .//config/database.php
=================================================================================

<?php

use Illuminate\Support\Str;

return [

    /*
    |--------------------------------------------------------------------------
    | Default Database Connection Name
    |--------------------------------------------------------------------------
    |
    | Here you may specify which of the database connections below you wish
    | to use as your default connection for database operations. This is
    | the connection which will be utilized unless another connection
    | is explicitly specified when you execute a query / statement.
    |
    */

    'default' => env('DB_CONNECTION', 'sqlite'),

    /*
    |--------------------------------------------------------------------------
    | Database Connections
    |--------------------------------------------------------------------------
    |
    | Below are all of the database connections defined for your application.
    | An example configuration is provided for each database system which
    | is supported by Laravel. You're free to add / remove connections.
    |
    */

    'connections' => [

        'sqlite' => [
            'driver' => 'sqlite',
            'url' => env('DB_URL'),
            'database' => env('DB_DATABASE', database_path('database.sqlite')),
            'prefix' => '',
            'foreign_key_constraints' => env('DB_FOREIGN_KEYS', true),
            'busy_timeout' => null,
            'journal_mode' => null,
            'synchronous' => null,
            'transaction_mode' => 'DEFERRED',
        ],

        'mysql' => [
            'driver' => 'mysql',
            'url' => env('DB_URL'),
            'host' => env('DB_HOST', '127.0.0.1'),
            'port' => env('DB_PORT', '3306'),
            'database' => env('DB_DATABASE', 'laravel'),
            'username' => env('DB_USERNAME', 'root'),
            'password' => env('DB_PASSWORD', ''),
            'unix_socket' => env('DB_SOCKET', ''),
            'charset' => env('DB_CHARSET', 'utf8mb4'),
            'collation' => env('DB_COLLATION', 'utf8mb4_unicode_ci'),
            'prefix' => '',
            'prefix_indexes' => true,
            'strict' => true,
            'engine' => null,
            'options' => extension_loaded('pdo_mysql') ? array_filter([
                (PHP_VERSION_ID >= 80500 ? \Pdo\Mysql::ATTR_SSL_CA : \PDO::MYSQL_ATTR_SSL_CA) => env('MYSQL_ATTR_SSL_CA'),
            ]) : [],
        ],

        'mariadb' => [
            'driver' => 'mariadb',
            'url' => env('DB_URL'),
            'host' => env('DB_HOST', '127.0.0.1'),
            'port' => env('DB_PORT', '3306'),
            'database' => env('DB_DATABASE', 'laravel'),
            'username' => env('DB_USERNAME', 'root'),
            'password' => env('DB_PASSWORD', ''),
            'unix_socket' => env('DB_SOCKET', ''),
            'charset' => env('DB_CHARSET', 'utf8mb4'),
            'collation' => env('DB_COLLATION', 'utf8mb4_unicode_ci'),
            'prefix' => '',
            'prefix_indexes' => true,
            'strict' => true,
            'engine' => null,
            'options' => extension_loaded('pdo_mysql') ? array_filter([
                (PHP_VERSION_ID >= 80500 ? \Pdo\Mysql::ATTR_SSL_CA : \PDO::MYSQL_ATTR_SSL_CA) => env('MYSQL_ATTR_SSL_CA'),
            ]) : [],
        ],

        'pgsql' => [
            'driver' => 'pgsql',
            'url' => env('DB_URL'),
            'host' => env('DB_HOST', '127.0.0.1'),
            'port' => env('DB_PORT', '5432'),
            'database' => env('DB_DATABASE', 'laravel'),
            'username' => env('DB_USERNAME', 'root'),
            'password' => env('DB_PASSWORD', ''),
            'charset' => env('DB_CHARSET', 'utf8'),
            'prefix' => '',
            'prefix_indexes' => true,
            'search_path' => 'public',
            'sslmode' => env('DB_SSLMODE', 'prefer'),
        ],

        'sqlsrv' => [
            'driver' => 'sqlsrv',
            'url' => env('DB_URL'),
            'host' => env('DB_HOST', 'localhost'),
            'port' => env('DB_PORT', '1433'),
            'database' => env('DB_DATABASE', 'laravel'),
            'username' => env('DB_USERNAME', 'root'),
            'password' => env('DB_PASSWORD', ''),
            'charset' => env('DB_CHARSET', 'utf8'),
            'prefix' => '',
            'prefix_indexes' => true,
            // 'encrypt' => env('DB_ENCRYPT', 'yes'),
            // 'trust_server_certificate' => env('DB_TRUST_SERVER_CERTIFICATE', 'false'),
        ],

    ],

    /*
    |--------------------------------------------------------------------------
    | Migration Repository Table
    |--------------------------------------------------------------------------
    |
    | This table keeps track of all the migrations that have already run for
    | your application. Using this information, we can determine which of
    | the migrations on disk haven't actually been run on the database.
    |
    */

    'migrations' => [
        'table' => 'migrations',
        'update_date_on_publish' => true,
    ],

    /*
    |--------------------------------------------------------------------------
    | Redis Databases
    |--------------------------------------------------------------------------
    |
    | Redis is an open source, fast, and advanced key-value store that also
    | provides a richer body of commands than a typical key-value system
    | such as Memcached. You may define your connection settings here.
    |
    */

    'redis' => [

        'client' => env('REDIS_CLIENT', 'phpredis'),

        'options' => [
            'cluster' => env('REDIS_CLUSTER', 'redis'),
            'prefix' => env('REDIS_PREFIX', Str::slug((string) env('APP_NAME', 'laravel')).'-database-'),
            'persistent' => env('REDIS_PERSISTENT', false),
        ],

        'default' => [
            'url' => env('REDIS_URL'),
            'host' => env('REDIS_HOST', '127.0.0.1'),
            'username' => env('REDIS_USERNAME'),
            'password' => env('REDIS_PASSWORD'),
            'port' => env('REDIS_PORT', '6379'),
            'database' => env('REDIS_DB', '0'),
            'max_retries' => env('REDIS_MAX_RETRIES', 3),
            'backoff_algorithm' => env('REDIS_BACKOFF_ALGORITHM', 'decorrelated_jitter'),
            'backoff_base' => env('REDIS_BACKOFF_BASE', 100),
            'backoff_cap' => env('REDIS_BACKOFF_CAP', 1000),
        ],

        'cache' => [
            'url' => env('REDIS_URL'),
            'host' => env('REDIS_HOST', '127.0.0.1'),
            'username' => env('REDIS_USERNAME'),
            'password' => env('REDIS_PASSWORD'),
            'port' => env('REDIS_PORT', '6379'),
            'database' => env('REDIS_CACHE_DB', '1'),
            'max_retries' => env('REDIS_MAX_RETRIES', 3),
            'backoff_algorithm' => env('REDIS_BACKOFF_ALGORITHM', 'decorrelated_jitter'),
            'backoff_base' => env('REDIS_BACKOFF_BASE', 100),
            'backoff_cap' => env('REDIS_BACKOFF_CAP', 1000),
        ],

    ],

];


=================================================================================
FILE: tests/Feature/ExampleTest.php
LOCATION: .//tests/Feature/ExampleTest.php
=================================================================================

<?php

namespace Tests\Feature;

// use Illuminate\Foundation\Testing\RefreshDatabase;
use Tests\TestCase;

class ExampleTest extends TestCase
{
    /**
     * A basic test example.
     */
    public function test_the_application_returns_a_successful_response(): void
    {
        $response = $this->get('/');

        $response->assertStatus(200);
    }
}


=================================================================================
FILE: app/Http/Resources/UserResource.php
LOCATION: .//app/Http/Resources/UserResource.php
=================================================================================

<?php

namespace App\Http\Resources;

use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;
use App\Enums\UserRole;

class UserResource extends JsonResource
{
    public function toArray(Request $request): array
    {
        $user = $request->user();
        $isActingAsWorker = false;

        // Scenariusz 1: Logowanie PIN-em (w tym momencie token jest dopiero tworzony,
        // nie ma go w nagłówku requestu, więc sprawdzamy endpoint)
        if ($user && $user->currentAccessToken()) {
            $token = $user->currentAccessToken();

            // ▼▼▼ POPRAWKA ▼▼▼
            // Sprawdzamy surowe uprawnienia (abilities).
            // Jeśli token ma '*', to jest to standardowe logowanie -> nie podmieniamy roli.
            // Podmieniamy TYLKO wtedy, gdy NIE ma '*' ORAZ ma 'act-as-worker'.
            if (!in_array('*', $token->abilities)) {
                $isActingAsWorker = $user->tokenCan('act-as-worker');
            }
        }

        return [
            'id' => $this->id,
            'name' => $this->name,
            'email' => $this->email,
            // Jeśli działa jako worker -> pokaż PRODUCTION_EMPLOYEE, w przeciwnym razie prawdziwa rola
            'role' => $isActingAsWorker ? UserRole::PRODUCTION_EMPLOYEE : $this->role,
            'is_active' => $this->is_active,
            'has_pin' => !is_null($this->pin_code),
        ];
    }
}



################################################################################
#                                                                              #
#                            END OF BACKEND CODE                               #
#                                                                              #
#  Export completed: 2026-02-28 08:00:03                                     #
#                                                                              #
################################################################################
